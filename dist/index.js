/*! For license information please see index.js.LICENSE.txt */
var mapboxGlDrawSnapOnMode;(()=>{var t={180:function(t){t.exports=function(){"use strict";function t(t,e){var n,r,o,i,s={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:l(0),throw:l(1),return:l(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function l(t){return function(e){return u([t,e])}}function u(i){if(n)throw new TypeError("Generator is already executing.");for(;s;)try{if(n=1,r&&(o=2&i[0]?r.return:i[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,i[1])).done)return o;switch(r=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,r=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!((o=(o=s.trys).length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){s.label=i[1];break}if(6===i[0]&&s.label<o[1]){s.label=o[1],o=i;break}if(o&&s.label<o[2]){s.label=o[2],s.ops.push(i);break}o[2]&&s.ops.pop(),s.trys.pop();continue}i=e.call(t,s)}catch(t){i=[6,t],r=0}finally{n=o=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}}var e=function(){function t(t,e){this.next=null,this.key=t,this.data=e,this.left=null,this.right=null}return t}();function n(t,e){return t>e?1:t<e?-1:0}function r(t,n,r){for(var o=new e(null,null),i=o,s=o;;){var l=r(t,n.key);if(l<0){if(null===n.left)break;if(r(t,n.left.key)<0){var u=n.left;if(n.left=u.right,u.right=n,null===(n=u).left)break}s.left=n,s=n,n=n.left}else{if(!(l>0))break;if(null===n.right)break;if(r(t,n.right.key)>0&&(u=n.right,n.right=u.left,u.left=n,null===(n=u).right))break;i.right=n,i=n,n=n.right}}return i.right=n.left,s.left=n.right,n.left=o.right,n.right=o.left,n}function o(t,n,o,i){var s=new e(t,n);if(null===o)return s.left=s.right=null,s;var l=i(t,(o=r(t,o,i)).key);return l<0?(s.left=o.left,s.right=o,o.left=null):l>=0&&(s.right=o.right,s.left=o,o.right=null),s}function i(t,e,n){var o=null,i=null;if(e){var s=n((e=r(t,e,n)).key,t);0===s?(o=e.left,i=e.right):s<0?(i=e.right,e.right=null,o=e):(o=e.left,e.left=null,i=e)}return{left:o,right:i}}function s(t,e,n){return null===e?t:(null===t||((e=r(t.key,e,n)).left=t),e)}function l(t,e,n,r,o){if(t){r(e+(n?"└── ":"├── ")+o(t)+"\n");var i=e+(n?"    ":"│   ");t.left&&l(t.left,i,!1,r,o),t.right&&l(t.right,i,!0,r,o)}}var u=function(){function u(t){void 0===t&&(t=n),this._root=null,this._size=0,this._comparator=t}return u.prototype.insert=function(t,e){return this._size++,this._root=o(t,e,this._root,this._comparator)},u.prototype.add=function(t,n){var o=new e(t,n);null===this._root&&(o.left=o.right=null,this._size++,this._root=o);var i=this._comparator,s=r(t,this._root,i),l=i(t,s.key);return 0===l?this._root=s:(l<0?(o.left=s.left,o.right=s,s.left=null):l>0&&(o.right=s.right,o.left=s,s.right=null),this._size++,this._root=o),this._root},u.prototype.remove=function(t){this._root=this._remove(t,this._root,this._comparator)},u.prototype._remove=function(t,e,n){var o;return null===e?null:0===n(t,(e=r(t,e,n)).key)?(null===e.left?o=e.right:(o=r(t,e.left,n)).right=e.right,this._size--,o):e},u.prototype.pop=function(){var t=this._root;if(t){for(;t.left;)t=t.left;return this._root=r(t.key,this._root,this._comparator),this._root=this._remove(t.key,this._root,this._comparator),{key:t.key,data:t.data}}return null},u.prototype.findStatic=function(t){for(var e=this._root,n=this._comparator;e;){var r=n(t,e.key);if(0===r)return e;e=r<0?e.left:e.right}return null},u.prototype.find=function(t){return this._root&&(this._root=r(t,this._root,this._comparator),0!==this._comparator(t,this._root.key))?null:this._root},u.prototype.contains=function(t){for(var e=this._root,n=this._comparator;e;){var r=n(t,e.key);if(0===r)return!0;e=r<0?e.left:e.right}return!1},u.prototype.forEach=function(t,e){for(var n=this._root,r=[],o=!1;!o;)null!==n?(r.push(n),n=n.left):0!==r.length?(n=r.pop(),t.call(e,n),n=n.right):o=!0;return this},u.prototype.range=function(t,e,n,r){for(var o=[],i=this._comparator,s=this._root;0!==o.length||s;)if(s)o.push(s),s=s.left;else{if(i((s=o.pop()).key,e)>0)break;if(i(s.key,t)>=0&&n.call(r,s))return this;s=s.right}return this},u.prototype.keys=function(){var t=[];return this.forEach((function(e){var n=e.key;return t.push(n)})),t},u.prototype.values=function(){var t=[];return this.forEach((function(e){var n=e.data;return t.push(n)})),t},u.prototype.min=function(){return this._root?this.minNode(this._root).key:null},u.prototype.max=function(){return this._root?this.maxNode(this._root).key:null},u.prototype.minNode=function(t){if(void 0===t&&(t=this._root),t)for(;t.left;)t=t.left;return t},u.prototype.maxNode=function(t){if(void 0===t&&(t=this._root),t)for(;t.right;)t=t.right;return t},u.prototype.at=function(t){for(var e=this._root,n=!1,r=0,o=[];!n;)if(e)o.push(e),e=e.left;else if(o.length>0){if(e=o.pop(),r===t)return e;r++,e=e.right}else n=!0;return null},u.prototype.next=function(t){var e=this._root,n=null;if(t.right){for(n=t.right;n.left;)n=n.left;return n}for(var r=this._comparator;e;){var o=r(t.key,e.key);if(0===o)break;o<0?(n=e,e=e.left):e=e.right}return n},u.prototype.prev=function(t){var e=this._root,n=null;if(null!==t.left){for(n=t.left;n.right;)n=n.right;return n}for(var r=this._comparator;e;){var o=r(t.key,e.key);if(0===o)break;o<0?e=e.left:(n=e,e=e.right)}return n},u.prototype.clear=function(){return this._root=null,this._size=0,this},u.prototype.toList=function(){return h(this._root)},u.prototype.load=function(t,e,n){void 0===e&&(e=[]),void 0===n&&(n=!1);var r=t.length,o=this._comparator;if(n&&g(t,e,0,r-1,o),null===this._root)this._root=a(t,e,0,r),this._size=r;else{var i=f(this.toList(),c(t,e),o);r=this._size+r,this._root=p({head:i},0,r)}return this},u.prototype.isEmpty=function(){return null===this._root},Object.defineProperty(u.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),u.prototype.toString=function(t){void 0===t&&(t=function(t){return String(t.key)});var e=[];return l(this._root,"",!0,(function(t){return e.push(t)}),t),e.join("")},u.prototype.update=function(t,e,n){var r=this._comparator,l=i(t,this._root,r),u=l.left,a=l.right;r(t,e)<0?a=o(e,n,a,r):u=o(e,n,u,r),this._root=s(u,a,r)},u.prototype.split=function(t){return i(t,this._root,this._comparator)},u.prototype[Symbol.iterator]=function(){var e,n,r;return t(this,(function(t){switch(t.label){case 0:e=this._root,n=[],r=!1,t.label=1;case 1:return r?[3,6]:null===e?[3,2]:(n.push(e),e=e.left,[3,5]);case 2:return 0===n.length?[3,4]:[4,e=n.pop()];case 3:return t.sent(),e=e.right,[3,5];case 4:r=!0,t.label=5;case 5:return[3,1];case 6:return[2]}}))},u}();function a(t,n,r,o){var i=o-r;if(i>0){var s=r+Math.floor(i/2),l=t[s],u=n[s],c=new e(l,u);return c.left=a(t,n,r,s),c.right=a(t,n,s+1,o),c}return null}function c(t,n){for(var r=new e(null,null),o=r,i=0;i<t.length;i++)o=o.next=new e(t[i],n[i]);return o.next=null,r.next}function h(t){for(var n=t,r=[],o=!1,i=new e(null,null),s=i;!o;)n?(r.push(n),n=n.left):r.length>0?n=(n=s=s.next=r.pop()).right:o=!0;return s.next=null,i.next}function p(t,e,n){var r=n-e;if(r>0){var o=e+Math.floor(r/2),i=p(t,e,o),s=t.head;return s.left=i,t.head=t.head.next,s.right=p(t,o+1,n),s}return null}function f(t,n,r){for(var o=new e(null,null),i=o,s=t,l=n;null!==s&&null!==l;)r(s.key,l.key)<0?(i.next=s,s=s.next):(i.next=l,l=l.next),i=i.next;return null!==s?i.next=s:null!==l&&(i.next=l),o.next}function g(t,e,n,r,o){if(!(n>=r)){for(var i=t[n+r>>1],s=n-1,l=r+1;;){do{s++}while(o(t[s],i)<0);do{l--}while(o(t[l],i)>0);if(s>=l)break;var u=t[s];t[s]=t[l],t[l]=u,u=e[s],e[s]=e[l],e[l]=u}g(t,e,n,l,o),g(t,e,l+1,r,o)}}const y=(t,e)=>t.ll.x<=e.x&&e.x<=t.ur.x&&t.ll.y<=e.y&&e.y<=t.ur.y,d=(t,e)=>{if(e.ur.x<t.ll.x||t.ur.x<e.ll.x||e.ur.y<t.ll.y||t.ur.y<e.ll.y)return null;const n=t.ll.x<e.ll.x?e.ll.x:t.ll.x,r=t.ur.x<e.ur.x?t.ur.x:e.ur.x;return{ll:{x:n,y:t.ll.y<e.ll.y?e.ll.y:t.ll.y},ur:{x:r,y:t.ur.y<e.ur.y?t.ur.y:e.ur.y}}};let m=Number.EPSILON;void 0===m&&(m=Math.pow(2,-52));const x=m*m,v=(t,e)=>{if(-m<t&&t<m&&-m<e&&e<m)return 0;const n=t-e;return n*n<x*t*e?0:t<e?-1:1};class b{constructor(){this.reset()}reset(){this.xRounder=new E,this.yRounder=new E}round(t,e){return{x:this.xRounder.round(t),y:this.yRounder.round(e)}}}class E{constructor(){this.tree=new u,this.round(0)}round(t){const e=this.tree.add(t),n=this.tree.prev(e);if(null!==n&&0===v(e.key,n.key))return this.tree.remove(t),n.key;const r=this.tree.next(e);return null!==r&&0===v(e.key,r.key)?(this.tree.remove(t),r.key):t}}const w=new b,S=11102230246251565e-32,_=134217729,P=(3+8*S)*S;function I(t,e,n,r,o){let i,s,l,u,a=e[0],c=r[0],h=0,p=0;c>a==c>-a?(i=a,a=e[++h]):(i=c,c=r[++p]);let f=0;if(h<t&&p<n)for(c>a==c>-a?(s=a+i,l=i-(s-a),a=e[++h]):(s=c+i,l=i-(s-c),c=r[++p]),i=s,0!==l&&(o[f++]=l);h<t&&p<n;)c>a==c>-a?(s=i+a,u=s-i,l=i-(s-u)+(a-u),a=e[++h]):(s=i+c,u=s-i,l=i-(s-u)+(c-u),c=r[++p]),i=s,0!==l&&(o[f++]=l);for(;h<t;)s=i+a,u=s-i,l=i-(s-u)+(a-u),a=e[++h],i=s,0!==l&&(o[f++]=l);for(;p<n;)s=i+c,u=s-i,l=i-(s-u)+(c-u),c=r[++p],i=s,0!==l&&(o[f++]=l);return 0===i&&0!==f||(o[f++]=i),f}function k(t,e){let n=e[0];for(let r=1;r<t;r++)n+=e[r];return n}function L(t){return new Float64Array(t)}const M=(3+16*S)*S,O=(2+12*S)*S,R=(9+64*S)*S*S,A=L(4),C=L(8),F=L(12),G=L(16),N=L(4);function T(t,e,n,r,o,i,s){let l,u,a,c,h,p,f,g,y,d,m,x,v,b,E,w,S,L;const M=t-o,T=n-o,j=e-i,D=r-i;b=M*D,p=_*M,f=p-(p-M),g=M-f,p=_*D,y=p-(p-D),d=D-y,E=g*d-(b-f*y-g*y-f*d),w=j*T,p=_*j,f=p-(p-j),g=j-f,p=_*T,y=p-(p-T),d=T-y,S=g*d-(w-f*y-g*y-f*d),m=E-S,h=E-m,A[0]=E-(m+h)+(h-S),x=b+m,h=x-b,v=b-(x-h)+(m-h),m=v-w,h=v-m,A[1]=v-(m+h)+(h-w),L=x+m,h=L-x,A[2]=x-(L-h)+(m-h),A[3]=L;let U=k(4,A),z=O*s;if(U>=z||-U>=z)return U;if(h=t-M,l=t-(M+h)+(h-o),h=n-T,a=n-(T+h)+(h-o),h=e-j,u=e-(j+h)+(h-i),h=r-D,c=r-(D+h)+(h-i),0===l&&0===u&&0===a&&0===c)return U;if(z=R*s+P*Math.abs(U),U+=M*c+D*l-(j*a+T*u),U>=z||-U>=z)return U;b=l*D,p=_*l,f=p-(p-l),g=l-f,p=_*D,y=p-(p-D),d=D-y,E=g*d-(b-f*y-g*y-f*d),w=u*T,p=_*u,f=p-(p-u),g=u-f,p=_*T,y=p-(p-T),d=T-y,S=g*d-(w-f*y-g*y-f*d),m=E-S,h=E-m,N[0]=E-(m+h)+(h-S),x=b+m,h=x-b,v=b-(x-h)+(m-h),m=v-w,h=v-m,N[1]=v-(m+h)+(h-w),L=x+m,h=L-x,N[2]=x-(L-h)+(m-h),N[3]=L;const V=I(4,A,4,N,C);b=M*c,p=_*M,f=p-(p-M),g=M-f,p=_*c,y=p-(p-c),d=c-y,E=g*d-(b-f*y-g*y-f*d),w=j*a,p=_*j,f=p-(p-j),g=j-f,p=_*a,y=p-(p-a),d=a-y,S=g*d-(w-f*y-g*y-f*d),m=E-S,h=E-m,N[0]=E-(m+h)+(h-S),x=b+m,h=x-b,v=b-(x-h)+(m-h),m=v-w,h=v-m,N[1]=v-(m+h)+(h-w),L=x+m,h=L-x,N[2]=x-(L-h)+(m-h),N[3]=L;const B=I(V,C,4,N,F);b=l*c,p=_*l,f=p-(p-l),g=l-f,p=_*c,y=p-(p-c),d=c-y,E=g*d-(b-f*y-g*y-f*d),w=u*a,p=_*u,f=p-(p-u),g=u-f,p=_*a,y=p-(p-a),d=a-y,S=g*d-(w-f*y-g*y-f*d),m=E-S,h=E-m,N[0]=E-(m+h)+(h-S),x=b+m,h=x-b,v=b-(x-h)+(m-h),m=v-w,h=v-m,N[1]=v-(m+h)+(h-w),L=x+m,h=L-x,N[2]=x-(L-h)+(m-h),N[3]=L;const $=I(B,F,4,N,G);return G[$-1]}function j(t,e,n,r,o,i){const s=(e-i)*(n-o),l=(t-o)*(r-i),u=s-l,a=Math.abs(s+l);return Math.abs(u)>=M*a?u:-T(t,e,n,r,o,i,a)}const D=(t,e)=>t.x*e.y-t.y*e.x,U=(t,e)=>t.x*e.x+t.y*e.y,z=(t,e,n)=>{const r=j(t.x,t.y,e.x,e.y,n.x,n.y);return r>0?-1:r<0?1:0},V=t=>Math.sqrt(U(t,t)),B=(t,e,n)=>{const r={x:e.x-t.x,y:e.y-t.y},o={x:n.x-t.x,y:n.y-t.y};return D(o,r)/V(o)/V(r)},$=(t,e,n)=>{const r={x:e.x-t.x,y:e.y-t.y},o={x:n.x-t.x,y:n.y-t.y};return U(o,r)/V(o)/V(r)},q=(t,e,n)=>0===e.y?null:{x:t.x+e.x/e.y*(n-t.y),y:n},H=(t,e,n)=>0===e.x?null:{x:n,y:t.y+e.y/e.x*(n-t.x)},Z=(t,e,n,r)=>{if(0===e.x)return H(n,r,t.x);if(0===r.x)return H(t,e,n.x);if(0===e.y)return q(n,r,t.y);if(0===r.y)return q(t,e,n.y);const o=D(e,r);if(0==o)return null;const i={x:n.x-t.x,y:n.y-t.y},s=D(i,e)/o,l=D(i,r)/o;return{x:(t.x+l*e.x+(n.x+s*r.x))/2,y:(t.y+l*e.y+(n.y+s*r.y))/2}};class Y{static compare(t,e){const n=Y.comparePoints(t.point,e.point);return 0!==n?n:(t.point!==e.point&&t.link(e),t.isLeft!==e.isLeft?t.isLeft?1:-1:X.compare(t.segment,e.segment))}static comparePoints(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}constructor(t,e){void 0===t.events?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}link(t){if(t.point===this.point)throw new Error("Tried to link already linked events");const e=t.point.events;for(let t=0,n=e.length;t<n;t++){const n=e[t];this.point.events.push(n),n.point=this.point}this.checkForConsuming()}checkForConsuming(){const t=this.point.events.length;for(let e=0;e<t;e++){const n=this.point.events[e];if(void 0===n.segment.consumedBy)for(let r=e+1;r<t;r++){const t=this.point.events[r];void 0===t.consumedBy&&n.otherSE.point.events===t.otherSE.point.events&&n.segment.consume(t.segment)}}}getAvailableLinkedEvents(){const t=[];for(let e=0,n=this.point.events.length;e<n;e++){const n=this.point.events[e];n!==this&&!n.segment.ringOut&&n.segment.isInResult()&&t.push(n)}return t}getLeftmostComparator(t){const e=new Map,n=n=>{const r=n.otherSE;e.set(n,{sine:B(this.point,t.point,r.point),cosine:$(this.point,t.point,r.point)})};return(t,r)=>{e.has(t)||n(t),e.has(r)||n(r);const{sine:o,cosine:i}=e.get(t),{sine:s,cosine:l}=e.get(r);return o>=0&&s>=0?i<l?1:i>l?-1:0:o<0&&s<0?i<l?-1:i>l?1:0:s<o?-1:s>o?1:0}}}let J=0;class X{static compare(t,e){const n=t.leftSE.point.x,r=e.leftSE.point.x,o=t.rightSE.point.x,i=e.rightSE.point.x;if(i<n)return 1;if(o<r)return-1;const s=t.leftSE.point.y,l=e.leftSE.point.y,u=t.rightSE.point.y,a=e.rightSE.point.y;if(n<r){if(l<s&&l<u)return 1;if(l>s&&l>u)return-1;const n=t.comparePoint(e.leftSE.point);if(n<0)return 1;if(n>0)return-1;const r=e.comparePoint(t.rightSE.point);return 0!==r?r:-1}if(n>r){if(s<l&&s<a)return-1;if(s>l&&s>a)return 1;const n=e.comparePoint(t.leftSE.point);if(0!==n)return n;const r=t.comparePoint(e.rightSE.point);return r<0?1:r>0?-1:1}if(s<l)return-1;if(s>l)return 1;if(o<i){const n=e.comparePoint(t.rightSE.point);if(0!==n)return n}if(o>i){const n=t.comparePoint(e.rightSE.point);if(n<0)return 1;if(n>0)return-1}if(o!==i){const t=u-s,e=o-n,c=a-l,h=i-r;if(t>e&&c<h)return 1;if(t<e&&c>h)return-1}return o>i?1:o<i||u<a?-1:u>a?1:t.id<e.id?-1:t.id>e.id?1:0}constructor(t,e,n,r){this.id=++J,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=n,this.windings=r}static fromRing(t,e,n){let r,o,i;const s=Y.comparePoints(t,e);if(s<0)r=t,o=e,i=1;else{if(!(s>0))throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);r=e,o=t,i=-1}const l=new Y(r,!0),u=new Y(o,!1);return new X(l,u,[n],[i])}replaceRightSE(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(t){return t.x===this.leftSE.point.x&&t.y===this.leftSE.point.y||t.x===this.rightSE.point.x&&t.y===this.rightSE.point.y}comparePoint(t){if(this.isAnEndpoint(t))return 0;const e=this.leftSE.point,n=this.rightSE.point,r=this.vector();if(e.x===n.x)return t.x===e.x?0:t.x<e.x?1:-1;const o=(t.y-e.y)/r.y,i=e.x+o*r.x;if(t.x===i)return 0;const s=(t.x-e.x)/r.x,l=e.y+s*r.y;return t.y===l?0:t.y<l?-1:1}getIntersection(t){const e=this.bbox(),n=t.bbox(),r=d(e,n);if(null===r)return null;const o=this.leftSE.point,i=this.rightSE.point,s=t.leftSE.point,l=t.rightSE.point,u=y(e,s)&&0===this.comparePoint(s),a=y(n,o)&&0===t.comparePoint(o),c=y(e,l)&&0===this.comparePoint(l),h=y(n,i)&&0===t.comparePoint(i);if(a&&u)return h&&!c?i:!h&&c?l:null;if(a)return c&&o.x===l.x&&o.y===l.y?null:o;if(u)return h&&i.x===s.x&&i.y===s.y?null:s;if(h&&c)return null;if(h)return i;if(c)return l;const p=Z(o,this.vector(),s,t.vector());return null===p?null:y(r,p)?w.round(p.x,p.y):null}split(t){const e=[],n=void 0!==t.events,r=new Y(t,!0),o=new Y(t,!1),i=this.rightSE;this.replaceRightSE(o),e.push(o),e.push(r);const s=new X(r,i,this.rings.slice(),this.windings.slice());return Y.comparePoints(s.leftSE.point,s.rightSE.point)>0&&s.swapEvents(),Y.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(r.checkForConsuming(),o.checkForConsuming()),e}swapEvents(){const t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let t=0,e=this.windings.length;t<e;t++)this.windings[t]*=-1}consume(t){let e=this,n=t;for(;e.consumedBy;)e=e.consumedBy;for(;n.consumedBy;)n=n.consumedBy;const r=X.compare(e,n);if(0!==r){if(r>0){const t=e;e=n,n=t}if(e.prev===n){const t=e;e=n,n=t}for(let t=0,r=n.rings.length;t<r;t++){const r=n.rings[t],o=n.windings[t],i=e.rings.indexOf(r);-1===i?(e.rings.push(r),e.windings.push(o)):e.windings[i]+=o}n.rings=null,n.windings=null,n.consumedBy=e,n.leftSE.consumedBy=e.leftSE,n.rightSE.consumedBy=e.rightSE}}prevInResult(){return void 0!==this._prevInResult||(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null),this._prevInResult}beforeState(){if(void 0!==this._beforeState)return this._beforeState;if(this.prev){const t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}else this._beforeState={rings:[],windings:[],multiPolys:[]};return this._beforeState}afterState(){if(void 0!==this._afterState)return this._afterState;const t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};const e=this._afterState.rings,n=this._afterState.windings,r=this._afterState.multiPolys;for(let t=0,r=this.rings.length;t<r;t++){const r=this.rings[t],o=this.windings[t],i=e.indexOf(r);-1===i?(e.push(r),n.push(o)):n[i]+=o}const o=[],i=[];for(let t=0,r=e.length;t<r;t++){if(0===n[t])continue;const r=e[t],s=r.poly;if(-1===i.indexOf(s))if(r.isExterior)o.push(s);else{-1===i.indexOf(s)&&i.push(s);const t=o.indexOf(r.poly);-1!==t&&o.splice(t,1)}}for(let t=0,e=o.length;t<e;t++){const e=o[t].multiPoly;-1===r.indexOf(e)&&r.push(e)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(void 0!==this._isInResult)return this._isInResult;const t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(lt.type){case"union":{const n=0===t.length,r=0===e.length;this._isInResult=n!==r;break}case"intersection":{let n,r;t.length<e.length?(n=t.length,r=e.length):(n=e.length,r=t.length),this._isInResult=r===lt.numMultiPolys&&n<r;break}case"xor":{const n=Math.abs(t.length-e.length);this._isInResult=n%2==1;break}case"difference":{const n=t=>1===t.length&&t[0].isSubject;this._isInResult=n(t)!==n(e);break}default:throw new Error(`Unrecognized operation type found ${lt.type}`)}return this._isInResult}}class K{constructor(t,e,n){if(!Array.isArray(t)||0===t.length)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=n,this.segments=[],"number"!=typeof t[0][0]||"number"!=typeof t[0][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const r=w.round(t[0][0],t[0][1]);this.bbox={ll:{x:r.x,y:r.y},ur:{x:r.x,y:r.y}};let o=r;for(let e=1,n=t.length;e<n;e++){if("number"!=typeof t[e][0]||"number"!=typeof t[e][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let n=w.round(t[e][0],t[e][1]);n.x===o.x&&n.y===o.y||(this.segments.push(X.fromRing(o,n,this)),n.x<this.bbox.ll.x&&(this.bbox.ll.x=n.x),n.y<this.bbox.ll.y&&(this.bbox.ll.y=n.y),n.x>this.bbox.ur.x&&(this.bbox.ur.x=n.x),n.y>this.bbox.ur.y&&(this.bbox.ur.y=n.y),o=n)}r.x===o.x&&r.y===o.y||this.segments.push(X.fromRing(o,r,this))}getSweepEvents(){const t=[];for(let e=0,n=this.segments.length;e<n;e++){const n=this.segments[e];t.push(n.leftSE),t.push(n.rightSE)}return t}}class Q{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new K(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let e=1,n=t.length;e<n;e++){const n=new K(t[e],this,!1);n.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=n.bbox.ll.x),n.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=n.bbox.ll.y),n.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=n.bbox.ur.x),n.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=n.bbox.ur.y),this.interiorRings.push(n)}this.multiPoly=e}getSweepEvents(){const t=this.exteriorRing.getSweepEvents();for(let e=0,n=this.interiorRings.length;e<n;e++){const n=this.interiorRings[e].getSweepEvents();for(let e=0,r=n.length;e<r;e++)t.push(n[e])}return t}}class W{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{"number"==typeof t[0][0][0]&&(t=[t])}catch(t){}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let e=0,n=t.length;e<n;e++){const n=new Q(t[e],this);n.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=n.bbox.ll.x),n.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=n.bbox.ll.y),n.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=n.bbox.ur.x),n.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=n.bbox.ur.y),this.polys.push(n)}this.isSubject=e}getSweepEvents(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const n=this.polys[e].getSweepEvents();for(let e=0,r=n.length;e<r;e++)t.push(n[e])}return t}}class tt{static factory(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n];if(!r.isInResult()||r.ringOut)continue;let o=null,i=r.leftSE,s=r.rightSE;const l=[i],u=i.point,a=[];for(;o=i,i=s,l.push(i),i.point!==u;)for(;;){const t=i.getAvailableLinkedEvents();if(0===t.length){const t=l[0].point,e=l[l.length-1].point;throw new Error(`Unable to complete output ring starting at [${t.x}, ${t.y}]. Last matching segment found ends at [${e.x}, ${e.y}].`)}if(1===t.length){s=t[0].otherSE;break}let n=null;for(let t=0,e=a.length;t<e;t++)if(a[t].point===i.point){n=t;break}if(null!==n){const t=a.splice(n)[0],r=l.splice(t.index);r.unshift(r[0].otherSE),e.push(new tt(r.reverse()));continue}a.push({index:l.length,point:i.point});const r=i.getLeftmostComparator(o);s=t.sort(r)[0].otherSE;break}e.push(new tt(l))}return e}constructor(t){this.events=t;for(let e=0,n=t.length;e<n;e++)t[e].segment.ringOut=this;this.poly=null}getGeom(){let t=this.events[0].point;const e=[t];for(let n=1,r=this.events.length-1;n<r;n++){const r=this.events[n].point,o=this.events[n+1].point;0!==z(r,t,o)&&(e.push(r),t=r)}if(1===e.length)return null;const n=e[0],r=e[1];0===z(n,t,r)&&e.shift(),e.push(e[0]);const o=this.isExteriorRing()?1:-1,i=this.isExteriorRing()?0:e.length-1,s=this.isExteriorRing()?e.length:-1,l=[];for(let t=i;t!=s;t+=o)l.push([e[t].x,e[t].y]);return l}isExteriorRing(){if(void 0===this._isExteriorRing){const t=this.enclosingRing();this._isExteriorRing=!t||!t.isExteriorRing()}return this._isExteriorRing}enclosingRing(){return void 0===this._enclosingRing&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let t=this.events[0];for(let e=1,n=this.events.length;e<n;e++){const n=this.events[e];Y.compare(t,n)>0&&(t=n)}let e=t.segment.prevInResult(),n=e?e.prevInResult():null;for(;;){if(!e)return null;if(!n)return e.ringOut;if(n.ringOut!==e.ringOut)return n.ringOut.enclosingRing()!==e.ringOut?e.ringOut:e.ringOut.enclosingRing();e=n.prevInResult(),n=e?e.prevInResult():null}}}class et{constructor(t){this.exteriorRing=t,t.poly=this,this.interiorRings=[]}addInterior(t){this.interiorRings.push(t),t.poly=this}getGeom(){const t=[this.exteriorRing.getGeom()];if(null===t[0])return null;for(let e=0,n=this.interiorRings.length;e<n;e++){const n=this.interiorRings[e].getGeom();null!==n&&t.push(n)}return t}}class nt{constructor(t){this.rings=t,this.polys=this._composePolys(t)}getGeom(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const n=this.polys[e].getGeom();null!==n&&t.push(n)}return t}_composePolys(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n];if(!r.poly)if(r.isExteriorRing())e.push(new et(r));else{const t=r.enclosingRing();t.poly||e.push(new et(t)),t.poly.addInterior(r)}}return e}}class rt{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:X.compare;this.queue=t,this.tree=new u(e),this.segments=[]}process(t){const e=t.segment,n=[];if(t.consumedBy)return t.isLeft?this.queue.remove(t.otherSE):this.tree.remove(e),n;const r=t.isLeft?this.tree.add(e):this.tree.find(e);if(!r)throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);let o,i,s=r,l=r;for(;void 0===o;)s=this.tree.prev(s),null===s?o=null:void 0===s.key.consumedBy&&(o=s.key);for(;void 0===i;)l=this.tree.next(l),null===l?i=null:void 0===l.key.consumedBy&&(i=l.key);if(t.isLeft){let r=null;if(o){const t=o.getIntersection(e);if(null!==t&&(e.isAnEndpoint(t)||(r=t),!o.isAnEndpoint(t))){const e=this._splitSafely(o,t);for(let t=0,r=e.length;t<r;t++)n.push(e[t])}}let s=null;if(i){const t=i.getIntersection(e);if(null!==t&&(e.isAnEndpoint(t)||(s=t),!i.isAnEndpoint(t))){const e=this._splitSafely(i,t);for(let t=0,r=e.length;t<r;t++)n.push(e[t])}}if(null!==r||null!==s){let t=null;t=null===r?s:null===s||Y.comparePoints(r,s)<=0?r:s,this.queue.remove(e.rightSE),n.push(e.rightSE);const o=e.split(t);for(let t=0,e=o.length;t<e;t++)n.push(o[t])}n.length>0?(this.tree.remove(e),n.push(t)):(this.segments.push(e),e.prev=o)}else{if(o&&i){const t=o.getIntersection(i);if(null!==t){if(!o.isAnEndpoint(t)){const e=this._splitSafely(o,t);for(let t=0,r=e.length;t<r;t++)n.push(e[t])}if(!i.isAnEndpoint(t)){const e=this._splitSafely(i,t);for(let t=0,r=e.length;t<r;t++)n.push(e[t])}}}this.tree.remove(e)}return n}_splitSafely(t,e){this.tree.remove(t);const n=t.rightSE;this.queue.remove(n);const r=t.split(e);return r.push(n),void 0===t.consumedBy&&this.tree.add(t),r}}const ot="undefined"!=typeof process&&process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,it="undefined"!=typeof process&&process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;class st{run(t,e,n){lt.type=t,w.reset();const r=[new W(e,!0)];for(let t=0,e=n.length;t<e;t++)r.push(new W(n[t],!1));if(lt.numMultiPolys=r.length,"difference"===lt.type){const t=r[0];let e=1;for(;e<r.length;)null!==d(r[e].bbox,t.bbox)?e++:r.splice(e,1)}if("intersection"===lt.type)for(let t=0,e=r.length;t<e;t++){const e=r[t];for(let n=t+1,o=r.length;n<o;n++)if(null===d(e.bbox,r[n].bbox))return[]}const o=new u(Y.compare);for(let t=0,e=r.length;t<e;t++){const e=r[t].getSweepEvents();for(let t=0,n=e.length;t<n;t++)if(o.insert(e[t]),o.size>ot)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const i=new rt(o);let s=o.size,l=o.pop();for(;l;){const t=l.key;if(o.size===s){const e=t.segment;throw new Error(`Unable to pop() ${t.isLeft?"left":"right"} SweepEvent [${t.point.x}, ${t.point.y}] from segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] from queue.`)}if(o.size>ot)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(i.segments.length>it)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const e=i.process(t);for(let t=0,n=e.length;t<n;t++){const n=e[t];void 0===n.consumedBy&&o.insert(n)}s=o.size,l=o.pop()}w.reset();const a=tt.factory(i.segments);return new nt(a).getGeom()}}const lt=new st,ut=function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return lt.run("union",t,n)},at=function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return lt.run("intersection",t,n)},ct=function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return lt.run("xor",t,n)},ht=function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return lt.run("difference",t,n)};return{union:ut,intersection:at,xor:ct,difference:ht}}()}},e={};function n(r){var o=e[r];if(void 0!==o)return o.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var r={};(()=>{"use strict";n.r(r),n.d(r,{SnapDirectSelect:()=>Xt,SnapModeDrawStyles:()=>Kt,SnapPolygonMode:()=>qt,Utils:()=>t});var t={};n.r(t),n.d(t,{IDS:()=>It,addPointTovertices:()=>kt,createSnapList:()=>Lt,getGuideFeature:()=>Ct,shouldHideGuide:()=>Ft,snap:()=>At});const e=void 0;var o=n.n(e),i=6371008.8,s={centimeters:637100880,centimetres:637100880,degrees:360/(2*Math.PI),feet:20902260.511392,inches:39.37*i,kilometers:6371.0088,kilometres:6371.0088,meters:i,metres:i,miles:3958.761333810546,millimeters:6371008800,millimetres:6371008800,nauticalmiles:i/1852,radians:1,yards:6967335.223679999};function l(t,e,n={}){const r={type:"Feature"};return(0===n.id||n.id)&&(r.id=n.id),n.bbox&&(r.bbox=n.bbox),r.properties=e||{},r.geometry=t,r}function u(t,e,n={}){if(!t)throw new Error("coordinates is required");if(!Array.isArray(t))throw new Error("coordinates must be an Array");if(t.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!x(t[0])||!x(t[1]))throw new Error("coordinates must contain numbers");return l({type:"Point",coordinates:t},e,n)}function a(t,e,n={}){for(const e of t){if(e.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(e[e.length-1].length!==e[0].length)throw new Error("First and last Position are not equivalent.");for(let t=0;t<e[e.length-1].length;t++)if(e[e.length-1][t]!==e[0][t])throw new Error("First and last Position are not equivalent.")}return l({type:"Polygon",coordinates:t},e,n)}function c(t,e,n={}){if(t.length<2)throw new Error("coordinates must be an array of two or more positions");return l({type:"LineString",coordinates:t},e,n)}function h(t,e={}){const n={type:"FeatureCollection"};return e.id&&(n.id=e.id),e.bbox&&(n.bbox=e.bbox),n.features=t,n}function p(t,e,n={}){return l({type:"MultiLineString",coordinates:t},e,n)}function f(t,e,n={}){return l({type:"MultiPolygon",coordinates:t},e,n)}function g(t,e="kilometers"){const n=s[e];if(!n)throw new Error(e+" units is invalid");return t*n}function y(t,e="kilometers"){const n=s[e];if(!n)throw new Error(e+" units is invalid");return t/n}function d(t){return 180*(t%(2*Math.PI))/Math.PI}function m(t){return t%360*Math.PI/180}function x(t){return!isNaN(t)&&null!==t&&!Array.isArray(t)}var v=function(t,e={}){const n=Number(t[0]),r=Number(t[1]),o=Number(t[2]),i=Number(t[3]);if(6===t.length)throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");const s=[n,r];return a([[s,[o,r],[o,i],[n,i],s]],e.properties,{bbox:t,id:e.id})};const b=function(t,e){for(var n=0,r=0,o=0,i=0,s=0,l=0,u=0,a=0,c=null,h=null,p=t[0],f=t[1],g=e.length;n<g;n++){r=0;var y=e[n].length-1,d=e[n];if((c=d[0])[0]!==d[y][0]&&c[1]!==d[y][1])throw new Error("First and last coordinates in a ring must be the same");for(s=c[0]-p,l=c[1]-f;r<y;r++)if(a=(h=d[r+1])[1]-f,l<0&&a<0||l>0&&a>0)l=a,s=(c=h)[0]-p;else{if(u=h[0]-t[0],a>0&&l<=0){if((i=s*a-u*l)>0)o+=1;else if(0===i)return 0}else if(l>0&&a<=0){if((i=s*a-u*l)<0)o+=1;else if(0===i)return 0}else if(0===a&&l<0){if(0===(i=s*a-u*l))return 0}else if(0===l&&a<0){if(0===(i=s*a-u*l))return 0}else if(0===l&&0===a){if(u<=0&&s>=0)return 0;if(s<=0&&u>=0)return 0}c=h,l=a,s=u}}return o%2!=0};function E(t){if(!t)throw new Error("coord is required");if(!Array.isArray(t)){if("Feature"===t.type&&null!==t.geometry&&"Point"===t.geometry.type)return[...t.geometry.coordinates];if("Point"===t.type)return[...t.coordinates]}if(Array.isArray(t)&&t.length>=2&&!Array.isArray(t[0])&&!Array.isArray(t[1]))return[...t];throw new Error("coord must be GeoJSON Point or an Array of numbers")}function w(t){if(Array.isArray(t))return t;if("Feature"===t.type){if(null!==t.geometry)return t.geometry.coordinates}else if(t.coordinates)return t.coordinates;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function S(t){return"Feature"===t.type?t.geometry:t}function _(t,e,n={}){if(!t)throw new Error("point is required");if(!e)throw new Error("polygon is required");const r=E(t),o=S(e),i=o.type,s=e.bbox;let l=o.coordinates;if(s&&!1===function(t,e){return e[0]<=t[0]&&e[1]<=t[1]&&e[2]>=t[0]&&e[3]>=t[1]}(r,s))return!1;"Polygon"===i&&(l=[l]);let u=!1;for(var a=0;a<l.length;++a){const t=b(r,l[a]);if(0===t)return!n.ignoreBoundary;t&&(u=!0)}return u}class P{constructor(t=[],e=I){if(this.data=t,this.length=this.data.length,this.compare=e,this.length>0)for(let t=(this.length>>1)-1;t>=0;t--)this._down(t)}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return;const t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}peek(){return this.data[0]}_up(t){const{data:e,compare:n}=this,r=e[t];for(;t>0;){const o=t-1>>1,i=e[o];if(n(r,i)>=0)break;e[t]=i,t=o}e[t]=r}_down(t){const{data:e,compare:n}=this,r=this.length>>1,o=e[t];for(;t<r;){let r=1+(t<<1),i=e[r];const s=r+1;if(s<this.length&&n(e[s],i)<0&&(r=s,i=e[s]),n(i,o)>=0)break;e[t]=i,t=r}e[t]=o}}function I(t,e){return t<e?-1:t>e?1:0}function k(t,e){return t.p.x>e.p.x?1:t.p.x<e.p.x?-1:t.p.y!==e.p.y?t.p.y>e.p.y?1:-1:1}function L(t,e){return t.rightSweepEvent.p.x>e.rightSweepEvent.p.x?1:t.rightSweepEvent.p.x<e.rightSweepEvent.p.x?-1:t.rightSweepEvent.p.y!==e.rightSweepEvent.p.y?t.rightSweepEvent.p.y<e.rightSweepEvent.p.y?1:-1:1}class M{constructor(t,e,n,r){this.p={x:t[0],y:t[1]},this.featureId=e,this.ringId=n,this.eventId=r,this.otherEvent=null,this.isLeftEndpoint=null}isSamePoint(t){return this.p.x===t.p.x&&this.p.y===t.p.y}}let O=0,R=0,A=0;function C(t,e){const n="Feature"===t.type?t.geometry:t;let r=n.coordinates;"Polygon"!==n.type&&"MultiLineString"!==n.type||(r=[r]),"LineString"===n.type&&(r=[[r]]);for(let t=0;t<r.length;t++)for(let n=0;n<r[t].length;n++){let o=r[t][n][0],i=null;R+=1;for(let s=0;s<r[t][n].length-1;s++){i=r[t][n][s+1];const l=new M(o,O,R,A),u=new M(i,O,R,A+1);l.otherEvent=u,u.otherEvent=l,k(l,u)>0?(u.isLeftEndpoint=!0,l.isLeftEndpoint=!1):(l.isLeftEndpoint=!0,u.isLeftEndpoint=!1),e.push(l),e.push(u),o=i,A+=1}}O+=1}class F{constructor(t){this.leftSweepEvent=t,this.rightSweepEvent=t.otherEvent}}function G(t,e){if(null===t||null===e)return!1;if(t.leftSweepEvent.ringId===e.leftSweepEvent.ringId&&(t.rightSweepEvent.isSamePoint(e.leftSweepEvent)||t.rightSweepEvent.isSamePoint(e.leftSweepEvent)||t.rightSweepEvent.isSamePoint(e.rightSweepEvent)||t.leftSweepEvent.isSamePoint(e.leftSweepEvent)||t.leftSweepEvent.isSamePoint(e.rightSweepEvent)))return!1;const n=t.leftSweepEvent.p.x,r=t.leftSweepEvent.p.y,o=t.rightSweepEvent.p.x,i=t.rightSweepEvent.p.y,s=e.leftSweepEvent.p.x,l=e.leftSweepEvent.p.y,u=e.rightSweepEvent.p.x,a=e.rightSweepEvent.p.y,c=(a-l)*(o-n)-(u-s)*(i-r),h=(u-s)*(r-l)-(a-l)*(n-s),p=(o-n)*(r-l)-(i-r)*(n-s);if(0===c)return!1;const f=h/c,g=p/c;if(f>=0&&f<=1&&g>=0&&g<=1){return[n+f*(o-n),r+f*(i-r)]}return!1}var N=function(t,e){const n=new P([],k);return function(t,e){if("FeatureCollection"===t.type){const n=t.features;for(let t=0;t<n.length;t++)C(n[t],e)}else C(t,e)}(t,n),function(t,e){e=e||!1;const n=[],r=new P([],L);for(;t.length;){const o=t.pop();if(o.isLeftEndpoint){const t=new F(o);for(let i=0;i<r.data.length;i++){const s=r.data[i];if(e&&s.leftSweepEvent.featureId===o.featureId)continue;const l=G(t,s);!1!==l&&n.push(l)}r.push(t)}else!1===o.isLeftEndpoint&&r.pop()}return n}(n,e)};function T(t,e,n={}){const{removeDuplicates:r=!0,ignoreSelfIntersections:o=!1}=n;let i=[];"FeatureCollection"===t.type?i=i.concat(t.features):"Feature"===t.type?i.push(t):"LineString"!==t.type&&"Polygon"!==t.type&&"MultiLineString"!==t.type&&"MultiPolygon"!==t.type||i.push(l(t)),"FeatureCollection"===e.type?i=i.concat(e.features):"Feature"===e.type?i.push(e):"LineString"!==e.type&&"Polygon"!==e.type&&"MultiLineString"!==e.type&&"MultiPolygon"!==e.type||i.push(l(e));const s=N(h(i),o);let a=[];if(r){const t={};s.forEach((e=>{const n=e.join(",");t[n]||(t[n]=!0,a.push(e))}))}else a=s;return h(a.map((t=>u(t))))}function j(t,e){if("Feature"===t.type)e(t,0);else if("FeatureCollection"===t.type)for(var n=0;n<t.features.length&&!1!==e(t.features[n],n);n++);}function D(t,e){var n,r,o,i,s,l,u,a,c,h,p=0,f="FeatureCollection"===t.type,g="Feature"===t.type,y=f?t.features.length:1;for(n=0;n<y;n++){for(l=f?t.features[n].geometry:g?t.geometry:t,a=f?t.features[n].properties:g?t.properties:{},c=f?t.features[n].bbox:g?t.bbox:void 0,h=f?t.features[n].id:g?t.id:void 0,s=(u=!!l&&"GeometryCollection"===l.type)?l.geometries.length:1,o=0;o<s;o++)if(null!==(i=u?l.geometries[o]:l))switch(i.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===e(i,p,a,c,h))return!1;break;case"GeometryCollection":for(r=0;r<i.geometries.length;r++)if(!1===e(i.geometries[r],p,a,c,h))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===e(null,p,a,c,h))return!1;p++}}function U(t,e){D(t,(function(t,n,r,o,i){var s,u=null===t?null:t.type;switch(u){case null:case"Point":case"LineString":case"Polygon":return!1!==e(l(t,r,{bbox:o,id:i}),n,0)&&void 0}switch(u){case"MultiPoint":s="Point";break;case"MultiLineString":s="LineString";break;case"MultiPolygon":s="Polygon"}for(var a=0;a<t.coordinates.length;a++){var c=t.coordinates[a];if(!1===e(l({type:s,coordinates:c},r),n,a))return!1}}))}function z(t,e={}){const n=S(t);switch(e.properties||"Feature"!==t.type||(e.properties=t.properties),n.type){case"Polygon":return function(t,e={}){const n=S(t),r=n.coordinates,o=e.properties?e.properties:"Feature"===t.type?t.properties:{};return V(r,o)}(n,e);case"MultiPolygon":return function(t,e={}){const n=S(t),r=n.coordinates,o=e.properties?e.properties:"Feature"===t.type?t.properties:{},i=[];return r.forEach((t=>{i.push(V(t,o))})),h(i)}(n,e);default:throw new Error("invalid poly")}}function V(t,e){return t.length>1?p(t,e):c(t[0],e)}var B=z;function $(t,e,n={}){var r;const o=null!=(r=n.ignoreSelfIntersections)&&r;let i=!0;return U(t,(t=>{U(e,(e=>{if(!1===i)return!1;i=function(t,e,n){switch(t.type){case"Point":switch(e.type){case"Point":return r=t.coordinates,o=e.coordinates,!(r[0]===o[0]&&r[1]===o[1]);case"LineString":return!q(e,t);case"Polygon":return!_(t,e)}break;case"LineString":switch(e.type){case"Point":return!q(t,e);case"LineString":return!function(t,e,n){const r=T(t,e,{ignoreSelfIntersections:n});if(r.features.length>0)return!0;return!1}(t,e,n);case"Polygon":return!H(e,t,n)}break;case"Polygon":switch(e.type){case"Point":return!_(e,t);case"LineString":return!H(t,e,n);case"Polygon":return!function(t,e,n){for(const n of t.coordinates[0])if(_(n,e))return!0;for(const n of e.coordinates[0])if(_(n,t))return!0;const r=T(z(t),z(e),{ignoreSelfIntersections:n});if(r.features.length>0)return!0;return!1}(e,t,n)}}var r,o;return!1}(t.geometry,e.geometry,o)}))})),i}function q(t,e){for(let n=0;n<t.coordinates.length-1;n++)if(Z(t.coordinates[n],t.coordinates[n+1],e.coordinates))return!0;return!1}function H(t,e,n){for(const n of e.coordinates)if(_(n,t))return!0;return T(e,z(t),{ignoreSelfIntersections:n}).features.length>0}function Z(t,e,n){const r=n[0]-t[0],o=n[1]-t[1],i=e[0]-t[0],s=e[1]-t[1];return 0==r*s-o*i&&(Math.abs(i)>=Math.abs(s)?i>0?t[0]<=n[0]&&n[0]<=e[0]:e[0]<=n[0]&&n[0]<=t[0]:s>0?t[1]<=n[1]&&n[1]<=e[1]:e[1]<=n[1]&&n[1]<=t[1])}var Y=$;function J(t,e,n={}){var r=E(t),o=E(e),i=m(o[1]-r[1]),s=m(o[0]-r[0]),l=m(r[1]),u=m(o[1]),a=Math.pow(Math.sin(i/2),2)+Math.pow(Math.sin(s/2),2)*Math.cos(l)*Math.cos(u);return g(2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)),n.units)}var X=J;function K(t,e,n={}){if(!0===n.final)return function(t,e){let n=K(e,t);return n=(n+180)%360,n}(t,e);const r=E(t),o=E(e),i=m(r[0]),s=m(o[0]),l=m(r[1]),u=m(o[1]),a=Math.sin(s-i)*Math.cos(u),c=Math.cos(l)*Math.sin(u)-Math.sin(l)*Math.cos(u)*Math.cos(s-i);return d(Math.atan2(a,c))}function Q(t,e,n,r={}){const o=E(t),i=m(o[0]),s=m(o[1]),l=m(n),a=y(e,r.units),c=Math.asin(Math.sin(s)*Math.cos(a)+Math.cos(s)*Math.sin(a)*Math.cos(l));return u([d(i+Math.atan2(Math.sin(l)*Math.sin(a)*Math.cos(s),Math.cos(a)-Math.sin(s)*Math.sin(c))),d(c)],r.properties)}var W=Object.defineProperty,tt=Object.defineProperties,et=Object.getOwnPropertyDescriptors,nt=Object.getOwnPropertySymbols,rt=Object.prototype.hasOwnProperty,ot=Object.prototype.propertyIsEnumerable,it=(t,e,n)=>e in t?W(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,st=(t,e)=>{for(var n in e||(e={}))rt.call(e,n)&&it(t,n,e[n]);if(nt)for(var n of nt(e))ot.call(e,n)&&it(t,n,e[n]);return t},lt=(t,e)=>tt(t,et(e));var ut=function(t,e,n={}){if(!t||!e)throw new Error("lines and pt are required arguments");let r=u([1/0,1/0],{dist:1/0,index:-1,multiFeatureIndex:-1,location:-1}),o=0;return U(t,(function(t,i,s){const l=w(t);for(let t=0;t<l.length-1;t++){const i=u(l[t]);i.properties.dist=J(e,i,n);const a=u(l[t+1]);a.properties.dist=J(e,a,n);const h=J(i,a,n),p=Math.max(i.properties.dist,a.properties.dist),f=K(i,a),g=Q(e,p,f+90,n),y=Q(e,p,f-90,n),d=T(c([g.geometry.coordinates,y.geometry.coordinates]),c([i.geometry.coordinates,a.geometry.coordinates]));let m;d.features.length>0&&d.features[0]&&(m=lt(st({},d.features[0]),{properties:{dist:J(e,d.features[0],n),multiFeatureIndex:s,location:o+J(i,d.features[0],n)}})),i.properties.dist<r.properties.dist&&(r=lt(st({},i),{properties:lt(st({},i.properties),{index:t,multiFeatureIndex:s,location:o})})),a.properties.dist<r.properties.dist&&(r=lt(st({},a),{properties:lt(st({},a.properties),{index:t+1,multiFeatureIndex:s,location:o+h})})),m&&m.properties.dist<r.properties.dist&&(r=lt(st({},m),{properties:lt(st({},m.properties),{index:t})})),o+=h}})),r};function at(t){if(!t)throw new Error("geojson is required");switch(t.type){case"Feature":return ct(t);case"FeatureCollection":return function(t){const e={type:"FeatureCollection"};return Object.keys(t).forEach((n=>{switch(n){case"type":case"features":return;default:e[n]=t[n]}})),e.features=t.features.map((t=>ct(t))),e}(t);case"Point":case"LineString":case"Polygon":case"MultiPoint":case"MultiLineString":case"MultiPolygon":case"GeometryCollection":return pt(t);default:throw new Error("unknown GeoJSON type")}}function ct(t){const e={type:"Feature"};return Object.keys(t).forEach((n=>{switch(n){case"type":case"properties":case"geometry":return;default:e[n]=t[n]}})),e.properties=ht(t.properties),null==t.geometry?e.geometry=null:e.geometry=pt(t.geometry),e}function ht(t){const e={};return t?(Object.keys(t).forEach((n=>{const r=t[n];"object"==typeof r?null===r?e[n]=null:Array.isArray(r)?e[n]=r.map((t=>t)):e[n]=ht(r):e[n]=r})),e):e}function pt(t){const e={type:t.type};return t.bbox&&(e.bbox=t.bbox),"GeometryCollection"===t.type?(e.geometries=t.geometries.map((t=>pt(t))),e):(e.coordinates=ft(t.coordinates),e)}function ft(t){const e=t;return"object"!=typeof e[0]?e.slice():e.map((t=>ft(t)))}var gt=Object.defineProperty,yt=Object.defineProperties,dt=Object.getOwnPropertyDescriptors,mt=Object.getOwnPropertySymbols,xt=Object.prototype.hasOwnProperty,vt=Object.prototype.propertyIsEnumerable,bt=(t,e,n)=>e in t?gt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,Et=(t,e)=>{for(var n in e||(e={}))xt.call(e,n)&&bt(t,n,e[n]);if(mt)for(var n of mt(e))vt.call(e,n)&&bt(t,n,e[n]);return t},wt=(t,e)=>yt(t,dt(e));var St=function(t,e,n={}){if(!t)throw new Error("targetPoint is required");if(!e)throw new Error("points is required");let r=1/0,o=0;j(e,((e,i)=>{const s=J(t,e,n);s<r&&(o=i,r=s)}));const i=at(e.features[o]);return wt(Et({},i),{properties:wt(Et({},i.properties),{featureIndex:o,distanceToPoint:r})})};var _t=function(t,e){return Q(t,J(t,e)/2,K(t,e))};const{geojsonTypes:Pt}=o().constants,It={VERTICAL_GUIDE:"VERTICAL_GUIDE",HORIZONTAL_GUIDE:"HORIZONTAL_GUIDE"},kt=(t,e,n,r)=>{const{width:o,height:i}=t.getCanvas(),{x:s,y:l}=t.project(n);(s>0&&s<o&&l>0&&l<i||r)&&e.push(n)},Lt=(t,e,n,r=[])=>{const o=r.map((e=>{const n=t.getSource(e);if("geojson"===(null==n?void 0:n.type)){const t=n._data;return t&&"string"!=typeof t?"FeatureCollection"===t.type?t.features:"Feature"===t.type?[t]:[]:[]}return[]})).flat(),i=e.getAll().features.concat(o),s=[],l=(()=>{const e=t.getCanvas(),n=e.width,r=e.height,o=(t.unproject([0,0]).toArray(),t.unproject([n,0]).toArray()),i=(t.unproject([n,r]).toArray(),t.unproject([0,r]).toArray());return v([i,o].flat())})(),u=[],a=(e,n=!1)=>{if(!Array.isArray(e))throw Error("Your array is not an array");Array.isArray(e[0])?e.forEach((t=>{a(t)})):2===e.length&&kt(t,u,e,n)};return i.forEach((t=>{t.id!==n.id?t.id!==It.HORIZONTAL_GUIDE&&t.id!==It.VERTICAL_GUIDE&&("GeometryCollection"!==t.geometry.type&&"Point"!==t.geometry.type&&a(t.geometry.coordinates),Y(l,t)||s.push(t)):n.type===Pt.POLYGON&&"GeometryCollection"!==t.geometry.type&&"Point"!==t.geometry.type&&a(t.geometry.coordinates[0].slice(0,-2),!0)})),[s,u]};function Mt(t,e){const n=t.map((t=>({feature:t,point:ut(t,e)})));return n.sort(((t,e)=>t.point.properties.dist-e.point.properties.dist)),{feature:n[0].feature,point:n[0].point}}const Ot=(t,e)=>{let n={};return e.forEach(((e,r)=>{const o=((t,e)=>{const n=[t.lng,t.lat],r="Point"===e.geometry.type,o="Polygon"===e.geometry.type,i="MultiPolygon"===e.geometry.type,s="MultiPoint"===e.geometry.type;let l;const a=w(e);if(r){const[t,e]=a;return{latlng:{lng:t,lat:e},distance:X(a,n)}}if(s){const t=St(n,h(a.map((t=>u(t))))),e=t.geometry.coordinates;return{latlng:{lng:e[0],lat:e[1]},distance:t.properties.distanceToPoint}}let p;if(l=o||i?B(e):e,o){let t;t="LineString"===l.geometry.type?[c(l.geometry.coordinates)]:l.geometry.coordinates.map((t=>c(t)));const e=Mt(t,n);l=e.feature,p=e.point}else if(i){const t=Mt(l.features.map((t=>"LineString"===t.geometry.type?[t.geometry.coordinates]:t.geometry.coordinates)).flatMap((t=>t)).map((t=>c(t))),n);l=t.feature,p=t.point}else p=ut(l,n);const[f,g]=p.geometry.coordinates;let y=p.properties.index;return y+1===l.geometry.coordinates.length&&y--,{latlng:{lng:f,lat:g},segment:l.geometry.coordinates.slice(y,y+2),distance:p.properties.dist,isMarker:r}})(t,e);(void 0===n.distance||o.distance<n.distance)&&(n=o,n.layer=e)})),n};const Rt=(t,e,n=1.25)=>!Array.isArray(t.segment)?function(t){return t.latlng}(t):function(t,e,n){const r=t.segment[0],o=t.segment[1],i=[t.latlng.lng,t.latlng.lat],s=X(r,i),l=X(o,i);let u,a=s<l?r:o,c=s<l?s:l;if(e&&e.snapToMidPoints){const t=_t(r,o).geometry.coordinates,e=X(t,i);e<s&&e<l&&(a=t,c=e)}u=c<n?a:i;const[h,p]=u;return{lng:h,lat:p}}(t,e,n),At=(t,e)=>{let n,r,o,i,s,l=e.lngLat.lng,u=e.lngLat.lat;if(e.originalEvent.altKey)return t.showVerticalSnapLine=!1,t.showHorizontalSnapLine=!1,{lng:l,lat:u};if(t.snapList.length<=0)return{lng:l,lat:u};if(t.options.snap){if(n=Ot({lng:l,lat:u},t.snapList),0===Object.keys(n).length)return!1;const e=n.isMarker,i=t.options.snapOptions?t.options.snapOptions.snapVertexPriorityDistance:void 0;o=e?n.latlng:Rt(n,t.options.snapOptions,i),r=(t.options.snapOptions&&t.options.snapOptions.snapPx||15)*function(t,e){const n=t*(Math.PI/180);return 40075017*Math.cos(n)/Math.pow(2,e+8)}(o.lat,t.map.getZoom())}if(t.options.guides){const n=((t,e)=>{const n=[],r=[];return t.forEach((t=>{n.push(t[0]),r.push(t[1])})),{verticalPx:n.find((t=>Math.abs(t-e.lng)<.009)),horizontalPx:r.find((t=>Math.abs(t-e.lat)<.009))}})(t.vertices,e.lngLat);if(i=n.verticalPx,s=n.horizontalPx,i){const n={lng:i,lat:e.lngLat.lat+10},r={lng:i,lat:e.lngLat.lat-10};t.verticalGuide.updateCoordinate(0,n.lng,n.lat),t.verticalGuide.updateCoordinate(1,r.lng,r.lat)}if(s){const n={lng:e.lngLat.lng+10,lat:s},r={lng:e.lngLat.lng-10,lat:s};t.horizontalGuide.updateCoordinate(0,n.lng,n.lat),t.horizontalGuide.updateCoordinate(1,r.lng,r.lat)}t.showVerticalSnapLine=!!i,t.showHorizontalSnapLine=!!s}return r&&n&&1e3*n.distance<r?o:i||s?(i&&(l=i),s&&(u=s),{lng:l,lat:u}):{lng:l,lat:u}},Ct=t=>({id:t,type:Pt.FEATURE,properties:{isSnapGuide:"true"},geometry:{type:Pt.LINE_STRING,coordinates:[]}}),Ft=(t,e)=>!(e.properties.id!==It.VERTICAL_GUIDE||t.options.guides&&t.showVerticalSnapLine)||!(e.properties.id!==It.HORIZONTAL_GUIDE||t.options.guides&&t.showHorizontalSnapLine);var Gt=function(t,e,n={}){var r;const o=null!=(r=n.ignoreSelfIntersections)&&r;let i=!1;return U(t,(t=>{U(e,(e=>{if(!0===i)return!0;i=!$(t.geometry,e.geometry,{ignoreSelfIntersections:o})}))})),i},Nt=n(180);function Tt(t,e){var n,r,o,i,s,l,u,a,c,h,p=0,f="FeatureCollection"===t.type,g="Feature"===t.type,y=f?t.features.length:1;for(n=0;n<y;n++){for(l=f?t.features[n].geometry:g?t.geometry:t,a=f?t.features[n].properties:g?t.properties:{},c=f?t.features[n].bbox:g?t.bbox:void 0,h=f?t.features[n].id:g?t.id:void 0,s=(u=!!l&&"GeometryCollection"===l.type)?l.geometries.length:1,o=0;o<s;o++)if(null!==(i=u?l.geometries[o]:l))switch(i.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===e(i,p,a,c,h))return!1;break;case"GeometryCollection":for(r=0;r<i.geometries.length;r++)if(!1===e(i.geometries[r],p,a,c,h))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===e(null,p,a,c,h))return!1;p++}}function jt(t){const e=[];if(Tt(t,(t=>{e.push(t.coordinates)})),e.length<2)throw new Error("Must have at least two features");const n=t.features[0].properties||{},r=Nt.difference(e[0],...e.slice(1));return 0===r.length?null:1===r.length?a(r[0],n):f(r,n)}const{geojsonTypes:Dt,modes:Ut,cursors:zt}=o().constants,{doubleClickZoom:Vt}=o().lib,Bt=o().modes.draw_polygon,$t=Object.assign({},Bt);$t.onSetup=function(t){const e=this.newFeature({type:Dt.FEATURE,properties:{},geometry:{type:Dt.POLYGON,coordinates:[[]]}}),n=this.newFeature(Ct(It.VERTICAL_GUIDE)),r=this.newFeature(Ct(It.HORIZONTAL_GUIDE));this.addFeature(e),this.addFeature(n),this.addFeature(r);const o=this.getSelected();this.clearSelectedFeatures(),Vt.disable(this);const[i,s]=Lt(this.map,this._ctx.api,e,this._ctx.options.snapOptions.sources),l={map:this.map,polygon:e,currentVertexPosition:0,vertices:s,snapList:i,selectedFeatures:o,verticalGuide:n,horizontalGuide:r,snappedLat:0,snappedLng:0,ghostPoint:u([0,0],{meta:"feature",active:"true"}),options:Object.assign(this._ctx.options,{overlap:!0})},a=()=>{const[t,n]=Lt(this.map,this._ctx.api,e,l.options.snapOptions.sources);l.vertices=n,l.snapList=t};l.moveendCallback=a;const c=t=>{l.options=t};return l.optionsChangedCallBAck=c,this.map.on("moveend",a),this.map.on("draw.snap.options_changed",c),l},$t.onClick=function(t,n){const r=t.snappedLng,o=t.snappedLat;if(t.currentVertexPosition>0&&(this.updateUIClasses({mouse:zt.POINTER}),e.lib.CommonSelectors.isVertex(n)))return this.changeMode(Ut.SIMPLE_SELECT,{featureIds:[t.polygon.id]});kt(t.map,t.vertices,{lng:r,lat:o}),t.polygon.updateCoordinate(`0.${t.currentVertexPosition}`,r,o),t.currentVertexPosition++,t.polygon.updateCoordinate(`0.${t.currentVertexPosition}`,r,o)},$t.onMouseMove=function(t,n){const{lng:r,lat:o}=At(t,n);t.snappedLng=r,t.snappedLat=o,t.ghostPoint.geometry.coordinates=[r,o],t.polygon.updateCoordinate(`0.${t.currentVertexPosition}`,r,o),e.lib.CommonSelectors.isVertex(n)?this.updateUIClasses({mouse:zt.POINTER}):this.updateUIClasses({mouse:zt.ADD})},$t.toDisplayFeatures=function(t,e,n){Ft(t,e)||(n(t.ghostPoint),Bt.toDisplayFeatures(t,e,n))},$t.onStop=function(t){this.deleteFeature(It.VERTICAL_GUIDE,{silent:!0}),this.deleteFeature(It.HORIZONTAL_GUIDE,{silent:!0}),this.map.off("moveend",t.moveendCallback),this.map.off("draw.snap.options_changed",t.optionsChangedCallBAck);var e=t.polygon;if(t.options.overlap)Bt.onStop.call(this,t);else{var n=this._ctx.store.getAll();try{var r=e;n.forEach((function(t){if(e.id===t.id)return!1;Gt(t,r)&&(r=jt(h([r,t])))})),t.polygon.coordinates=r.coordinates||r.geometry.coordinates}catch(e){return Bt.onStop.call(this,t),void this.deleteFeature(t.polygon.id,{silent:!0})}var o=t.polygon.removeCoordinate;t.polygon.removeCoordinate=()=>{},Bt.onStop.call(this,t),t.polygon.removeCoordinate=o.bind(t.polygon)}};const qt=$t,{doubleClickZoom:Ht}=o().lib,Zt=o().modes.direct_select,Yt=o().constants,Jt=Object.assign({},Zt);Jt.onSetup=function(t){const e=t.featureId,n=this.getFeature(e);if(!n)throw new Error("You must provide a featureId to enter direct_select mode");if(n.type===Yt.geojsonTypes.POINT)throw new TypeError("direct_select mode doesn't handle point features");const[r,o]=Lt(this.map,this._ctx.api,n,this._ctx.options.snapOptions.sources),i=this.newFeature(Ct(It.VERTICAL_GUIDE)),s=this.newFeature(Ct(It.HORIZONTAL_GUIDE));this.addFeature(i),this.addFeature(s);const l={map:this.map,featureId:e,feature:n,dragMoveLocation:t.startPos||null,dragMoving:!1,canDragMove:!1,selectedCoordPaths:t.coordPath?[t.coordPath]:[],vertices:o,snapList:r,verticalGuide:i,horizontalGuide:s,options:{},optionsChangedCallBAck:t=>{}};l.options=this._ctx.options,this.setSelectedCoordinates(this.pathsToCoordinates(e,l.selectedCoordPaths)),this.setSelected(e),Ht.disable(this),this.setActionableState({trash:!0,combineFeatures:!1,uncombineFeatures:!1});const u=t=>{l.options=t};return l.optionsChangedCallBAck=u,this.map.on("draw.snap.options_changed",u),l},Jt.dragVertex=function(t,e,n){const{lng:r,lat:o}=At(t,e);t.feature.updateCoordinate(t.selectedCoordPaths[0],r,o)},Jt.onStop=function(t){var e;this.deleteFeature(It.VERTICAL_GUIDE,{silent:!0}),this.deleteFeature(It.HORIZONTAL_GUIDE,{silent:!0}),this.map.off("draw.snap.options_changed",t.optionsChangedCallBAck),null===(e=Zt.onStop)||void 0===e||e.call(this,t)};const Xt=Jt,Kt=[...e.lib.theme.map((t=>"gl-draw-line-inactive"===t.id?Object.assign(Object.assign({},t),{filter:[...(null==t?void 0:t.filter)||[],["!=","user_isSnapGuide","true"]]}):t)),{id:"guide",type:"line",filter:["all",["==","$type","LineString"],["==","user_isSnapGuide","true"]],layout:{"line-cap":"round","line-join":"round"},paint:{"line-color":"#c00c00","line-width":1,"line-dasharray":[5,5]}}]})(),mapboxGlDrawSnapOnMode=r})();
//# sourceMappingURL=index.js.map