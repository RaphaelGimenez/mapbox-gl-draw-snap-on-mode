{"version":3,"file":"index.js","mappings":"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","sources":["webpack://mapboxGlDrawSnapOnMode/./node_modules/.pnpm/polygon-clipping@0.15.7/node_modules/polygon-clipping/dist/polygon-clipping.umd.js","webpack://mapboxGlDrawSnapOnMode/webpack/bootstrap","webpack://mapboxGlDrawSnapOnMode/webpack/runtime/compat get default export","webpack://mapboxGlDrawSnapOnMode/webpack/runtime/define property getters","webpack://mapboxGlDrawSnapOnMode/webpack/runtime/hasOwnProperty shorthand","webpack://mapboxGlDrawSnapOnMode/webpack/runtime/make namespace object","webpack://mapboxGlDrawSnapOnMode/external var {\"commonjs\":\"@mapbox/mapbox-gl-draw\",\"commonjs2\":\"@mapbox/mapbox-gl-draw\",\"amd\":\"@mapbox/mapbox-gl-draw\",\"root\":\"MapboxDraw\"}","webpack://mapboxGlDrawSnapOnMode/./node_modules/.pnpm/@turf+helpers@7.1.0/node_modules/@turf/helpers/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/bbox-polygon/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/point-in-polygon-hao/dist/pointInPolygon.mjs","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/invariant/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/sweepline-intersections/dist/sweeplineIntersections.esm.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/line-intersect/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/meta/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/polygon-to-line/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/boolean-disjoint/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/distance/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/bearing/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/destination/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/nearest-point-on-line/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/clone/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/nearest-point/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/midpoint/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./src/utils/index.ts","webpack://mapboxGlDrawSnapOnMode/./node_modules/@turf/boolean-intersects/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/.pnpm/@turf+meta@7.1.0/node_modules/@turf/meta/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./node_modules/.pnpm/@turf+difference@7.1.0/node_modules/@turf/difference/dist/esm/index.js","webpack://mapboxGlDrawSnapOnMode/./src/modes/snap_polygon.ts","webpack://mapboxGlDrawSnapOnMode/./src/modes/snap_direct_select.ts","webpack://mapboxGlDrawSnapOnMode/./src/utils/customDrawStyles.ts"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.polygonClipping = factory());\n})(this, (function () { 'use strict';\n\n    /**\n     * splaytree v3.1.2\n     * Fast Splay tree for Node and browser\n     *\n     * @author Alexander Milevski <info@w8r.name>\n     * @license MIT\n     * @preserve\n     */\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\n\n    function __generator(thisArg, body) {\n      var _ = {\n          label: 0,\n          sent: function () {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n          },\n          trys: [],\n          ops: []\n        },\n        f,\n        y,\n        t,\n        g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n            case 7:\n              op = _.ops.pop();\n              _.trys.pop();\n              continue;\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n                _.ops.push(op);\n                break;\n              }\n              if (t[2]) _.ops.pop();\n              _.trys.pop();\n              continue;\n          }\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    }\n    var Node = /** @class */function () {\n      function Node(key, data) {\n        this.next = null;\n        this.key = key;\n        this.data = data;\n        this.left = null;\n        this.right = null;\n      }\n      return Node;\n    }();\n\n    /* follows \"An implementation of top-down splaying\"\r\n     * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n     */\n    function DEFAULT_COMPARE(a, b) {\n      return a > b ? 1 : a < b ? -1 : 0;\n    }\n    /**\r\n     * Simple top down splay, not requiring i to be in the tree t.\r\n     */\n    function splay(i, t, comparator) {\n      var N = new Node(null, null);\n      var l = N;\n      var r = N;\n      while (true) {\n        var cmp = comparator(i, t.key);\n        //if (i < t.key) {\n        if (cmp < 0) {\n          if (t.left === null) break;\n          //if (i < t.left.key) {\n          if (comparator(i, t.left.key) < 0) {\n            var y = t.left; /* rotate right */\n            t.left = y.right;\n            y.right = t;\n            t = y;\n            if (t.left === null) break;\n          }\n          r.left = t; /* link right */\n          r = t;\n          t = t.left;\n          //} else if (i > t.key) {\n        } else if (cmp > 0) {\n          if (t.right === null) break;\n          //if (i > t.right.key) {\n          if (comparator(i, t.right.key) > 0) {\n            var y = t.right; /* rotate left */\n            t.right = y.left;\n            y.left = t;\n            t = y;\n            if (t.right === null) break;\n          }\n          l.right = t; /* link left */\n          l = t;\n          t = t.right;\n        } else break;\n      }\n      /* assemble */\n      l.right = t.left;\n      r.left = t.right;\n      t.left = N.right;\n      t.right = N.left;\n      return t;\n    }\n    function insert(i, data, t, comparator) {\n      var node = new Node(i, data);\n      if (t === null) {\n        node.left = node.right = null;\n        return node;\n      }\n      t = splay(i, t, comparator);\n      var cmp = comparator(i, t.key);\n      if (cmp < 0) {\n        node.left = t.left;\n        node.right = t;\n        t.left = null;\n      } else if (cmp >= 0) {\n        node.right = t.right;\n        node.left = t;\n        t.right = null;\n      }\n      return node;\n    }\n    function split(key, v, comparator) {\n      var left = null;\n      var right = null;\n      if (v) {\n        v = splay(key, v, comparator);\n        var cmp = comparator(v.key, key);\n        if (cmp === 0) {\n          left = v.left;\n          right = v.right;\n        } else if (cmp < 0) {\n          right = v.right;\n          v.right = null;\n          left = v;\n        } else {\n          left = v.left;\n          v.left = null;\n          right = v;\n        }\n      }\n      return {\n        left: left,\n        right: right\n      };\n    }\n    function merge(left, right, comparator) {\n      if (right === null) return left;\n      if (left === null) return right;\n      right = splay(left.key, right, comparator);\n      right.left = left;\n      return right;\n    }\n    /**\r\n     * Prints level of the tree\r\n     */\n    function printRow(root, prefix, isTail, out, printNode) {\n      if (root) {\n        out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\n        var indent = prefix + (isTail ? '    ' : '│   ');\n        if (root.left) printRow(root.left, indent, false, out, printNode);\n        if (root.right) printRow(root.right, indent, true, out, printNode);\n      }\n    }\n    var Tree = /** @class */function () {\n      function Tree(comparator) {\n        if (comparator === void 0) {\n          comparator = DEFAULT_COMPARE;\n        }\n        this._root = null;\n        this._size = 0;\n        this._comparator = comparator;\n      }\n      /**\r\n       * Inserts a key, allows duplicates\r\n       */\n      Tree.prototype.insert = function (key, data) {\n        this._size++;\n        return this._root = insert(key, data, this._root, this._comparator);\n      };\n      /**\r\n       * Adds a key, if it is not present in the tree\r\n       */\n      Tree.prototype.add = function (key, data) {\n        var node = new Node(key, data);\n        if (this._root === null) {\n          node.left = node.right = null;\n          this._size++;\n          this._root = node;\n        }\n        var comparator = this._comparator;\n        var t = splay(key, this._root, comparator);\n        var cmp = comparator(key, t.key);\n        if (cmp === 0) this._root = t;else {\n          if (cmp < 0) {\n            node.left = t.left;\n            node.right = t;\n            t.left = null;\n          } else if (cmp > 0) {\n            node.right = t.right;\n            node.left = t;\n            t.right = null;\n          }\n          this._size++;\n          this._root = node;\n        }\n        return this._root;\n      };\n      /**\r\n       * @param  {Key} key\r\n       * @return {Node|null}\r\n       */\n      Tree.prototype.remove = function (key) {\n        this._root = this._remove(key, this._root, this._comparator);\n      };\n      /**\r\n       * Deletes i from the tree if it's there\r\n       */\n      Tree.prototype._remove = function (i, t, comparator) {\n        var x;\n        if (t === null) return null;\n        t = splay(i, t, comparator);\n        var cmp = comparator(i, t.key);\n        if (cmp === 0) {\n          /* found it */\n          if (t.left === null) {\n            x = t.right;\n          } else {\n            x = splay(i, t.left, comparator);\n            x.right = t.right;\n          }\n          this._size--;\n          return x;\n        }\n        return t; /* It wasn't there */\n      };\n      /**\r\n       * Removes and returns the node with smallest key\r\n       */\n      Tree.prototype.pop = function () {\n        var node = this._root;\n        if (node) {\n          while (node.left) node = node.left;\n          this._root = splay(node.key, this._root, this._comparator);\n          this._root = this._remove(node.key, this._root, this._comparator);\n          return {\n            key: node.key,\n            data: node.data\n          };\n        }\n        return null;\n      };\n      /**\r\n       * Find without splaying\r\n       */\n      Tree.prototype.findStatic = function (key) {\n        var current = this._root;\n        var compare = this._comparator;\n        while (current) {\n          var cmp = compare(key, current.key);\n          if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;\n        }\n        return null;\n      };\n      Tree.prototype.find = function (key) {\n        if (this._root) {\n          this._root = splay(key, this._root, this._comparator);\n          if (this._comparator(key, this._root.key) !== 0) return null;\n        }\n        return this._root;\n      };\n      Tree.prototype.contains = function (key) {\n        var current = this._root;\n        var compare = this._comparator;\n        while (current) {\n          var cmp = compare(key, current.key);\n          if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;\n        }\n        return false;\n      };\n      Tree.prototype.forEach = function (visitor, ctx) {\n        var current = this._root;\n        var Q = []; /* Initialize stack s */\n        var done = false;\n        while (!done) {\n          if (current !== null) {\n            Q.push(current);\n            current = current.left;\n          } else {\n            if (Q.length !== 0) {\n              current = Q.pop();\n              visitor.call(ctx, current);\n              current = current.right;\n            } else done = true;\n          }\n        }\n        return this;\n      };\n      /**\r\n       * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n       */\n      Tree.prototype.range = function (low, high, fn, ctx) {\n        var Q = [];\n        var compare = this._comparator;\n        var node = this._root;\n        var cmp;\n        while (Q.length !== 0 || node) {\n          if (node) {\n            Q.push(node);\n            node = node.left;\n          } else {\n            node = Q.pop();\n            cmp = compare(node.key, high);\n            if (cmp > 0) {\n              break;\n            } else if (compare(node.key, low) >= 0) {\n              if (fn.call(ctx, node)) return this; // stop if smth is returned\n            }\n            node = node.right;\n          }\n        }\n        return this;\n      };\n      /**\r\n       * Returns array of keys\r\n       */\n      Tree.prototype.keys = function () {\n        var keys = [];\n        this.forEach(function (_a) {\n          var key = _a.key;\n          return keys.push(key);\n        });\n        return keys;\n      };\n      /**\r\n       * Returns array of all the data in the nodes\r\n       */\n      Tree.prototype.values = function () {\n        var values = [];\n        this.forEach(function (_a) {\n          var data = _a.data;\n          return values.push(data);\n        });\n        return values;\n      };\n      Tree.prototype.min = function () {\n        if (this._root) return this.minNode(this._root).key;\n        return null;\n      };\n      Tree.prototype.max = function () {\n        if (this._root) return this.maxNode(this._root).key;\n        return null;\n      };\n      Tree.prototype.minNode = function (t) {\n        if (t === void 0) {\n          t = this._root;\n        }\n        if (t) while (t.left) t = t.left;\n        return t;\n      };\n      Tree.prototype.maxNode = function (t) {\n        if (t === void 0) {\n          t = this._root;\n        }\n        if (t) while (t.right) t = t.right;\n        return t;\n      };\n      /**\r\n       * Returns node at given index\r\n       */\n      Tree.prototype.at = function (index) {\n        var current = this._root;\n        var done = false;\n        var i = 0;\n        var Q = [];\n        while (!done) {\n          if (current) {\n            Q.push(current);\n            current = current.left;\n          } else {\n            if (Q.length > 0) {\n              current = Q.pop();\n              if (i === index) return current;\n              i++;\n              current = current.right;\n            } else done = true;\n          }\n        }\n        return null;\n      };\n      Tree.prototype.next = function (d) {\n        var root = this._root;\n        var successor = null;\n        if (d.right) {\n          successor = d.right;\n          while (successor.left) successor = successor.left;\n          return successor;\n        }\n        var comparator = this._comparator;\n        while (root) {\n          var cmp = comparator(d.key, root.key);\n          if (cmp === 0) break;else if (cmp < 0) {\n            successor = root;\n            root = root.left;\n          } else root = root.right;\n        }\n        return successor;\n      };\n      Tree.prototype.prev = function (d) {\n        var root = this._root;\n        var predecessor = null;\n        if (d.left !== null) {\n          predecessor = d.left;\n          while (predecessor.right) predecessor = predecessor.right;\n          return predecessor;\n        }\n        var comparator = this._comparator;\n        while (root) {\n          var cmp = comparator(d.key, root.key);\n          if (cmp === 0) break;else if (cmp < 0) root = root.left;else {\n            predecessor = root;\n            root = root.right;\n          }\n        }\n        return predecessor;\n      };\n      Tree.prototype.clear = function () {\n        this._root = null;\n        this._size = 0;\n        return this;\n      };\n      Tree.prototype.toList = function () {\n        return toList(this._root);\n      };\n      /**\r\n       * Bulk-load items. Both array have to be same size\r\n       */\n      Tree.prototype.load = function (keys, values, presort) {\n        if (values === void 0) {\n          values = [];\n        }\n        if (presort === void 0) {\n          presort = false;\n        }\n        var size = keys.length;\n        var comparator = this._comparator;\n        // sort if needed\n        if (presort) sort(keys, values, 0, size - 1, comparator);\n        if (this._root === null) {\n          // empty tree\n          this._root = loadRecursive(keys, values, 0, size);\n          this._size = size;\n        } else {\n          // that re-builds the whole tree from two in-order traversals\n          var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n          size = this._size + size;\n          this._root = sortedListToBST({\n            head: mergedList\n          }, 0, size);\n        }\n        return this;\n      };\n      Tree.prototype.isEmpty = function () {\n        return this._root === null;\n      };\n      Object.defineProperty(Tree.prototype, \"size\", {\n        get: function () {\n          return this._size;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(Tree.prototype, \"root\", {\n        get: function () {\n          return this._root;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Tree.prototype.toString = function (printNode) {\n        if (printNode === void 0) {\n          printNode = function (n) {\n            return String(n.key);\n          };\n        }\n        var out = [];\n        printRow(this._root, '', true, function (v) {\n          return out.push(v);\n        }, printNode);\n        return out.join('');\n      };\n      Tree.prototype.update = function (key, newKey, newData) {\n        var comparator = this._comparator;\n        var _a = split(key, this._root, comparator),\n          left = _a.left,\n          right = _a.right;\n        if (comparator(key, newKey) < 0) {\n          right = insert(newKey, newData, right, comparator);\n        } else {\n          left = insert(newKey, newData, left, comparator);\n        }\n        this._root = merge(left, right, comparator);\n      };\n      Tree.prototype.split = function (key) {\n        return split(key, this._root, this._comparator);\n      };\n      Tree.prototype[Symbol.iterator] = function () {\n        var current, Q, done;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              current = this._root;\n              Q = [];\n              done = false;\n              _a.label = 1;\n            case 1:\n              if (!!done) return [3 /*break*/, 6];\n              if (!(current !== null)) return [3 /*break*/, 2];\n              Q.push(current);\n              current = current.left;\n              return [3 /*break*/, 5];\n            case 2:\n              if (!(Q.length !== 0)) return [3 /*break*/, 4];\n              current = Q.pop();\n              return [4 /*yield*/, current];\n            case 3:\n              _a.sent();\n              current = current.right;\n              return [3 /*break*/, 5];\n            case 4:\n              done = true;\n              _a.label = 5;\n            case 5:\n              return [3 /*break*/, 1];\n            case 6:\n              return [2 /*return*/];\n          }\n        });\n      };\n      return Tree;\n    }();\n    function loadRecursive(keys, values, start, end) {\n      var size = end - start;\n      if (size > 0) {\n        var middle = start + Math.floor(size / 2);\n        var key = keys[middle];\n        var data = values[middle];\n        var node = new Node(key, data);\n        node.left = loadRecursive(keys, values, start, middle);\n        node.right = loadRecursive(keys, values, middle + 1, end);\n        return node;\n      }\n      return null;\n    }\n    function createList(keys, values) {\n      var head = new Node(null, null);\n      var p = head;\n      for (var i = 0; i < keys.length; i++) {\n        p = p.next = new Node(keys[i], values[i]);\n      }\n      p.next = null;\n      return head.next;\n    }\n    function toList(root) {\n      var current = root;\n      var Q = [];\n      var done = false;\n      var head = new Node(null, null);\n      var p = head;\n      while (!done) {\n        if (current) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length > 0) {\n            current = p = p.next = Q.pop();\n            current = current.right;\n          } else done = true;\n        }\n      }\n      p.next = null; // that'll work even if the tree was empty\n      return head.next;\n    }\n    function sortedListToBST(list, start, end) {\n      var size = end - start;\n      if (size > 0) {\n        var middle = start + Math.floor(size / 2);\n        var left = sortedListToBST(list, start, middle);\n        var root = list.head;\n        root.left = left;\n        list.head = list.head.next;\n        root.right = sortedListToBST(list, middle + 1, end);\n        return root;\n      }\n      return null;\n    }\n    function mergeLists(l1, l2, compare) {\n      var head = new Node(null, null); // dummy\n      var p = head;\n      var p1 = l1;\n      var p2 = l2;\n      while (p1 !== null && p2 !== null) {\n        if (compare(p1.key, p2.key) < 0) {\n          p.next = p1;\n          p1 = p1.next;\n        } else {\n          p.next = p2;\n          p2 = p2.next;\n        }\n        p = p.next;\n      }\n      if (p1 !== null) {\n        p.next = p1;\n      } else if (p2 !== null) {\n        p.next = p2;\n      }\n      return head.next;\n    }\n    function sort(keys, values, left, right, compare) {\n      if (left >= right) return;\n      var pivot = keys[left + right >> 1];\n      var i = left - 1;\n      var j = right + 1;\n      while (true) {\n        do i++; while (compare(keys[i], pivot) < 0);\n        do j--; while (compare(keys[j], pivot) > 0);\n        if (i >= j) break;\n        var tmp = keys[i];\n        keys[i] = keys[j];\n        keys[j] = tmp;\n        tmp = values[i];\n        values[i] = values[j];\n        values[j] = tmp;\n      }\n      sort(keys, values, left, j, compare);\n      sort(keys, values, j + 1, right, compare);\n    }\n\n    /**\n     * A bounding box has the format:\n     *\n     *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n     *\n     */\n\n    const isInBbox = (bbox, point) => {\n      return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n    };\n\n    /* Returns either null, or a bbox (aka an ordered pair of points)\n     * If there is only one point of overlap, a bbox with identical points\n     * will be returned */\n    const getBboxOverlap = (b1, b2) => {\n      // check if the bboxes overlap at all\n      if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;\n\n      // find the middle two X values\n      const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n      const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;\n\n      // find the middle two Y values\n      const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n      const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;\n\n      // put those middle values together to get the overlap\n      return {\n        ll: {\n          x: lowerX,\n          y: lowerY\n        },\n        ur: {\n          x: upperX,\n          y: upperY\n        }\n      };\n    };\n\n    /* Javascript doesn't do integer math. Everything is\n     * floating point with percision Number.EPSILON.\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n     */\n\n    let epsilon$1 = Number.EPSILON;\n\n    // IE Polyfill\n    if (epsilon$1 === undefined) epsilon$1 = Math.pow(2, -52);\n    const EPSILON_SQ = epsilon$1 * epsilon$1;\n\n    /* FLP comparator */\n    const cmp = (a, b) => {\n      // check if they're both 0\n      if (-epsilon$1 < a && a < epsilon$1) {\n        if (-epsilon$1 < b && b < epsilon$1) {\n          return 0;\n        }\n      }\n\n      // check if they're flp equal\n      const ab = a - b;\n      if (ab * ab < EPSILON_SQ * a * b) {\n        return 0;\n      }\n\n      // normal comparison\n      return a < b ? -1 : 1;\n    };\n\n    /**\n     * This class rounds incoming values sufficiently so that\n     * floating points problems are, for the most part, avoided.\n     *\n     * Incoming points are have their x & y values tested against\n     * all previously seen x & y values. If either is 'too close'\n     * to a previously seen value, it's value is 'snapped' to the\n     * previously seen value.\n     *\n     * All points should be rounded by this class before being\n     * stored in any data structures in the rest of this algorithm.\n     */\n\n    class PtRounder {\n      constructor() {\n        this.reset();\n      }\n      reset() {\n        this.xRounder = new CoordRounder();\n        this.yRounder = new CoordRounder();\n      }\n      round(x, y) {\n        return {\n          x: this.xRounder.round(x),\n          y: this.yRounder.round(y)\n        };\n      }\n    }\n    class CoordRounder {\n      constructor() {\n        this.tree = new Tree();\n        // preseed with 0 so we don't end up with values < Number.EPSILON\n        this.round(0);\n      }\n\n      // Note: this can rounds input values backwards or forwards.\n      //       You might ask, why not restrict this to just rounding\n      //       forwards? Wouldn't that allow left endpoints to always\n      //       remain left endpoints during splitting (never change to\n      //       right). No - it wouldn't, because we snap intersections\n      //       to endpoints (to establish independence from the segment\n      //       angle for t-intersections).\n      round(coord) {\n        const node = this.tree.add(coord);\n        const prevNode = this.tree.prev(node);\n        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n          this.tree.remove(coord);\n          return prevNode.key;\n        }\n        const nextNode = this.tree.next(node);\n        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n          this.tree.remove(coord);\n          return nextNode.key;\n        }\n        return coord;\n      }\n    }\n\n    // singleton available by import\n    const rounder = new PtRounder();\n\n    const epsilon = 1.1102230246251565e-16;\n    const splitter = 134217729;\n    const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n    // fast_expansion_sum_zeroelim routine from oritinal code\n    function sum(elen, e, flen, f, h) {\n      let Q, Qnew, hh, bvirt;\n      let enow = e[0];\n      let fnow = f[0];\n      let eindex = 0;\n      let findex = 0;\n      if (fnow > enow === fnow > -enow) {\n        Q = enow;\n        enow = e[++eindex];\n      } else {\n        Q = fnow;\n        fnow = f[++findex];\n      }\n      let hindex = 0;\n      if (eindex < elen && findex < flen) {\n        if (fnow > enow === fnow > -enow) {\n          Qnew = enow + Q;\n          hh = Q - (Qnew - enow);\n          enow = e[++eindex];\n        } else {\n          Qnew = fnow + Q;\n          hh = Q - (Qnew - fnow);\n          fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n          h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n          if (fnow > enow === fnow > -enow) {\n            Qnew = Q + enow;\n            bvirt = Qnew - Q;\n            hh = Q - (Qnew - bvirt) + (enow - bvirt);\n            enow = e[++eindex];\n          } else {\n            Qnew = Q + fnow;\n            bvirt = Qnew - Q;\n            hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n            fnow = f[++findex];\n          }\n          Q = Qnew;\n          if (hh !== 0) {\n            h[hindex++] = hh;\n          }\n        }\n      }\n      while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n          h[hindex++] = hh;\n        }\n      }\n      while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n          h[hindex++] = hh;\n        }\n      }\n      if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n      }\n      return hindex;\n    }\n    function estimate(elen, e) {\n      let Q = e[0];\n      for (let i = 1; i < elen; i++) Q += e[i];\n      return Q;\n    }\n    function vec(n) {\n      return new Float64Array(n);\n    }\n\n    const ccwerrboundA = (3 + 16 * epsilon) * epsilon;\n    const ccwerrboundB = (2 + 12 * epsilon) * epsilon;\n    const ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n    const B = vec(4);\n    const C1 = vec(8);\n    const C2 = vec(12);\n    const D = vec(16);\n    const u = vec(4);\n    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n      let acxtail, acytail, bcxtail, bcytail;\n      let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n      const acx = ax - cx;\n      const bcx = bx - cx;\n      const acy = ay - cy;\n      const bcy = by - cy;\n      s1 = acx * bcy;\n      c = splitter * acx;\n      ahi = c - (c - acx);\n      alo = acx - ahi;\n      c = splitter * bcy;\n      bhi = c - (c - bcy);\n      blo = bcy - bhi;\n      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n      t1 = acy * bcx;\n      c = splitter * acy;\n      ahi = c - (c - acy);\n      alo = acy - ahi;\n      c = splitter * bcx;\n      bhi = c - (c - bcx);\n      blo = bcx - bhi;\n      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n      _i = s0 - t0;\n      bvirt = s0 - _i;\n      B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n      _j = s1 + _i;\n      bvirt = _j - s1;\n      _0 = s1 - (_j - bvirt) + (_i - bvirt);\n      _i = _0 - t1;\n      bvirt = _0 - _i;\n      B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n      u3 = _j + _i;\n      bvirt = u3 - _j;\n      B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n      B[3] = u3;\n      let det = estimate(4, B);\n      let errbound = ccwerrboundB * detsum;\n      if (det >= errbound || -det >= errbound) {\n        return det;\n      }\n      bvirt = ax - acx;\n      acxtail = ax - (acx + bvirt) + (bvirt - cx);\n      bvirt = bx - bcx;\n      bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n      bvirt = ay - acy;\n      acytail = ay - (acy + bvirt) + (bvirt - cy);\n      bvirt = by - bcy;\n      bcytail = by - (bcy + bvirt) + (bvirt - cy);\n      if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n      }\n      errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n      det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);\n      if (det >= errbound || -det >= errbound) return det;\n      s1 = acxtail * bcy;\n      c = splitter * acxtail;\n      ahi = c - (c - acxtail);\n      alo = acxtail - ahi;\n      c = splitter * bcy;\n      bhi = c - (c - bcy);\n      blo = bcy - bhi;\n      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n      t1 = acytail * bcx;\n      c = splitter * acytail;\n      ahi = c - (c - acytail);\n      alo = acytail - ahi;\n      c = splitter * bcx;\n      bhi = c - (c - bcx);\n      blo = bcx - bhi;\n      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n      _i = s0 - t0;\n      bvirt = s0 - _i;\n      u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n      _j = s1 + _i;\n      bvirt = _j - s1;\n      _0 = s1 - (_j - bvirt) + (_i - bvirt);\n      _i = _0 - t1;\n      bvirt = _0 - _i;\n      u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n      u3 = _j + _i;\n      bvirt = u3 - _j;\n      u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n      u[3] = u3;\n      const C1len = sum(4, B, 4, u, C1);\n      s1 = acx * bcytail;\n      c = splitter * acx;\n      ahi = c - (c - acx);\n      alo = acx - ahi;\n      c = splitter * bcytail;\n      bhi = c - (c - bcytail);\n      blo = bcytail - bhi;\n      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n      t1 = acy * bcxtail;\n      c = splitter * acy;\n      ahi = c - (c - acy);\n      alo = acy - ahi;\n      c = splitter * bcxtail;\n      bhi = c - (c - bcxtail);\n      blo = bcxtail - bhi;\n      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n      _i = s0 - t0;\n      bvirt = s0 - _i;\n      u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n      _j = s1 + _i;\n      bvirt = _j - s1;\n      _0 = s1 - (_j - bvirt) + (_i - bvirt);\n      _i = _0 - t1;\n      bvirt = _0 - _i;\n      u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n      u3 = _j + _i;\n      bvirt = u3 - _j;\n      u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n      u[3] = u3;\n      const C2len = sum(C1len, C1, 4, u, C2);\n      s1 = acxtail * bcytail;\n      c = splitter * acxtail;\n      ahi = c - (c - acxtail);\n      alo = acxtail - ahi;\n      c = splitter * bcytail;\n      bhi = c - (c - bcytail);\n      blo = bcytail - bhi;\n      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n      t1 = acytail * bcxtail;\n      c = splitter * acytail;\n      ahi = c - (c - acytail);\n      alo = acytail - ahi;\n      c = splitter * bcxtail;\n      bhi = c - (c - bcxtail);\n      blo = bcxtail - bhi;\n      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n      _i = s0 - t0;\n      bvirt = s0 - _i;\n      u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n      _j = s1 + _i;\n      bvirt = _j - s1;\n      _0 = s1 - (_j - bvirt) + (_i - bvirt);\n      _i = _0 - t1;\n      bvirt = _0 - _i;\n      u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n      u3 = _j + _i;\n      bvirt = u3 - _j;\n      u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n      u[3] = u3;\n      const Dlen = sum(C2len, C2, 4, u, D);\n      return D[Dlen - 1];\n    }\n    function orient2d(ax, ay, bx, by, cx, cy) {\n      const detleft = (ay - cy) * (bx - cx);\n      const detright = (ax - cx) * (by - cy);\n      const det = detleft - detright;\n      const detsum = Math.abs(detleft + detright);\n      if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n      return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n    }\n\n    /* Cross Product of two vectors with first point at origin */\n    const crossProduct = (a, b) => a.x * b.y - a.y * b.x;\n\n    /* Dot Product of two vectors with first point at origin */\n    const dotProduct = (a, b) => a.x * b.x + a.y * b.y;\n\n    /* Comparator for two vectors with same starting point */\n    const compareVectorAngles = (basePt, endPt1, endPt2) => {\n      const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);\n      if (res > 0) return -1;\n      if (res < 0) return 1;\n      return 0;\n    };\n    const length = v => Math.sqrt(dotProduct(v, v));\n\n    /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n    const sineOfAngle = (pShared, pBase, pAngle) => {\n      const vBase = {\n        x: pBase.x - pShared.x,\n        y: pBase.y - pShared.y\n      };\n      const vAngle = {\n        x: pAngle.x - pShared.x,\n        y: pAngle.y - pShared.y\n      };\n      return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n    };\n\n    /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n    const cosineOfAngle = (pShared, pBase, pAngle) => {\n      const vBase = {\n        x: pBase.x - pShared.x,\n        y: pBase.y - pShared.y\n      };\n      const vAngle = {\n        x: pAngle.x - pShared.x,\n        y: pAngle.y - pShared.y\n      };\n      return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n    };\n\n    /* Get the x coordinate where the given line (defined by a point and vector)\n     * crosses the horizontal line with the given y coordiante.\n     * In the case of parrallel lines (including overlapping ones) returns null. */\n    const horizontalIntersection = (pt, v, y) => {\n      if (v.y === 0) return null;\n      return {\n        x: pt.x + v.x / v.y * (y - pt.y),\n        y: y\n      };\n    };\n\n    /* Get the y coordinate where the given line (defined by a point and vector)\n     * crosses the vertical line with the given x coordiante.\n     * In the case of parrallel lines (including overlapping ones) returns null. */\n    const verticalIntersection = (pt, v, x) => {\n      if (v.x === 0) return null;\n      return {\n        x: x,\n        y: pt.y + v.y / v.x * (x - pt.x)\n      };\n    };\n\n    /* Get the intersection of two lines, each defined by a base point and a vector.\n     * In the case of parrallel lines (including overlapping ones) returns null. */\n    const intersection$1 = (pt1, v1, pt2, v2) => {\n      // take some shortcuts for vertical and horizontal lines\n      // this also ensures we don't calculate an intersection and then discover\n      // it's actually outside the bounding box of the line\n      if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n      if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n      if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n      if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);\n\n      // General case for non-overlapping segments.\n      // This algorithm is based on Schneider and Eberly.\n      // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n      const kross = crossProduct(v1, v2);\n      if (kross == 0) return null;\n      const ve = {\n        x: pt2.x - pt1.x,\n        y: pt2.y - pt1.y\n      };\n      const d1 = crossProduct(ve, v1) / kross;\n      const d2 = crossProduct(ve, v2) / kross;\n\n      // take the average of the two calculations to minimize rounding error\n      const x1 = pt1.x + d2 * v1.x,\n        x2 = pt2.x + d1 * v2.x;\n      const y1 = pt1.y + d2 * v1.y,\n        y2 = pt2.y + d1 * v2.y;\n      const x = (x1 + x2) / 2;\n      const y = (y1 + y2) / 2;\n      return {\n        x: x,\n        y: y\n      };\n    };\n\n    class SweepEvent {\n      // for ordering sweep events in the sweep event queue\n      static compare(a, b) {\n        // favor event with a point that the sweep line hits first\n        const ptCmp = SweepEvent.comparePoints(a.point, b.point);\n        if (ptCmp !== 0) return ptCmp;\n\n        // the points are the same, so link them if needed\n        if (a.point !== b.point) a.link(b);\n\n        // favor right events over left\n        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n\n        // we have two matching left or right endpoints\n        // ordering of this case is the same as for their segments\n        return Segment.compare(a.segment, b.segment);\n      }\n\n      // for ordering points in sweep line order\n      static comparePoints(aPt, bPt) {\n        if (aPt.x < bPt.x) return -1;\n        if (aPt.x > bPt.x) return 1;\n        if (aPt.y < bPt.y) return -1;\n        if (aPt.y > bPt.y) return 1;\n        return 0;\n      }\n\n      // Warning: 'point' input will be modified and re-used (for performance)\n      constructor(point, isLeft) {\n        if (point.events === undefined) point.events = [this];else point.events.push(this);\n        this.point = point;\n        this.isLeft = isLeft;\n        // this.segment, this.otherSE set by factory\n      }\n      link(other) {\n        if (other.point === this.point) {\n          throw new Error(\"Tried to link already linked events\");\n        }\n        const otherEvents = other.point.events;\n        for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n          const evt = otherEvents[i];\n          this.point.events.push(evt);\n          evt.point = this.point;\n        }\n        this.checkForConsuming();\n      }\n\n      /* Do a pass over our linked events and check to see if any pair\n       * of segments match, and should be consumed. */\n      checkForConsuming() {\n        // FIXME: The loops in this method run O(n^2) => no good.\n        //        Maintain little ordered sweep event trees?\n        //        Can we maintaining an ordering that avoids the need\n        //        for the re-sorting with getLeftmostComparator in geom-out?\n\n        // Compare each pair of events to see if other events also match\n        const numEvents = this.point.events.length;\n        for (let i = 0; i < numEvents; i++) {\n          const evt1 = this.point.events[i];\n          if (evt1.segment.consumedBy !== undefined) continue;\n          for (let j = i + 1; j < numEvents; j++) {\n            const evt2 = this.point.events[j];\n            if (evt2.consumedBy !== undefined) continue;\n            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n            evt1.segment.consume(evt2.segment);\n          }\n        }\n      }\n      getAvailableLinkedEvents() {\n        // point.events is always of length 2 or greater\n        const events = [];\n        for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n          const evt = this.point.events[i];\n          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n            events.push(evt);\n          }\n        }\n        return events;\n      }\n\n      /**\n       * Returns a comparator function for sorting linked events that will\n       * favor the event that will give us the smallest left-side angle.\n       * All ring construction starts as low as possible heading to the right,\n       * so by always turning left as sharp as possible we'll get polygons\n       * without uncessary loops & holes.\n       *\n       * The comparator function has a compute cache such that it avoids\n       * re-computing already-computed values.\n       */\n      getLeftmostComparator(baseEvent) {\n        const cache = new Map();\n        const fillCache = linkedEvent => {\n          const nextEvent = linkedEvent.otherSE;\n          cache.set(linkedEvent, {\n            sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n            cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n          });\n        };\n        return (a, b) => {\n          if (!cache.has(a)) fillCache(a);\n          if (!cache.has(b)) fillCache(b);\n          const {\n            sine: asine,\n            cosine: acosine\n          } = cache.get(a);\n          const {\n            sine: bsine,\n            cosine: bcosine\n          } = cache.get(b);\n\n          // both on or above x-axis\n          if (asine >= 0 && bsine >= 0) {\n            if (acosine < bcosine) return 1;\n            if (acosine > bcosine) return -1;\n            return 0;\n          }\n\n          // both below x-axis\n          if (asine < 0 && bsine < 0) {\n            if (acosine < bcosine) return -1;\n            if (acosine > bcosine) return 1;\n            return 0;\n          }\n\n          // one above x-axis, one below\n          if (bsine < asine) return -1;\n          if (bsine > asine) return 1;\n          return 0;\n        };\n      }\n    }\n\n    // Give segments unique ID's to get consistent sorting of\n    // segments and sweep events when all else is identical\n    let segmentId = 0;\n    class Segment {\n      /* This compare() function is for ordering segments in the sweep\n       * line tree, and does so according to the following criteria:\n       *\n       * Consider the vertical line that lies an infinestimal step to the\n       * right of the right-more of the two left endpoints of the input\n       * segments. Imagine slowly moving a point up from negative infinity\n       * in the increasing y direction. Which of the two segments will that\n       * point intersect first? That segment comes 'before' the other one.\n       *\n       * If neither segment would be intersected by such a line, (if one\n       * or more of the segments are vertical) then the line to be considered\n       * is directly on the right-more of the two left inputs.\n       */\n      static compare(a, b) {\n        const alx = a.leftSE.point.x;\n        const blx = b.leftSE.point.x;\n        const arx = a.rightSE.point.x;\n        const brx = b.rightSE.point.x;\n\n        // check if they're even in the same vertical plane\n        if (brx < alx) return 1;\n        if (arx < blx) return -1;\n        const aly = a.leftSE.point.y;\n        const bly = b.leftSE.point.y;\n        const ary = a.rightSE.point.y;\n        const bry = b.rightSE.point.y;\n\n        // is left endpoint of segment B the right-more?\n        if (alx < blx) {\n          // are the two segments in the same horizontal plane?\n          if (bly < aly && bly < ary) return 1;\n          if (bly > aly && bly > ary) return -1;\n\n          // is the B left endpoint colinear to segment A?\n          const aCmpBLeft = a.comparePoint(b.leftSE.point);\n          if (aCmpBLeft < 0) return 1;\n          if (aCmpBLeft > 0) return -1;\n\n          // is the A right endpoint colinear to segment B ?\n          const bCmpARight = b.comparePoint(a.rightSE.point);\n          if (bCmpARight !== 0) return bCmpARight;\n\n          // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n          return -1;\n        }\n\n        // is left endpoint of segment A the right-more?\n        if (alx > blx) {\n          if (aly < bly && aly < bry) return -1;\n          if (aly > bly && aly > bry) return 1;\n\n          // is the A left endpoint colinear to segment B?\n          const bCmpALeft = b.comparePoint(a.leftSE.point);\n          if (bCmpALeft !== 0) return bCmpALeft;\n\n          // is the B right endpoint colinear to segment A?\n          const aCmpBRight = a.comparePoint(b.rightSE.point);\n          if (aCmpBRight < 0) return 1;\n          if (aCmpBRight > 0) return -1;\n\n          // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n          return 1;\n        }\n\n        // if we get here, the two left endpoints are in the same\n        // vertical plane, ie alx === blx\n\n        // consider the lower left-endpoint to come first\n        if (aly < bly) return -1;\n        if (aly > bly) return 1;\n\n        // left endpoints are identical\n        // check for colinearity by using the left-more right endpoint\n\n        // is the A right endpoint more left-more?\n        if (arx < brx) {\n          const bCmpARight = b.comparePoint(a.rightSE.point);\n          if (bCmpARight !== 0) return bCmpARight;\n        }\n\n        // is the B right endpoint more left-more?\n        if (arx > brx) {\n          const aCmpBRight = a.comparePoint(b.rightSE.point);\n          if (aCmpBRight < 0) return 1;\n          if (aCmpBRight > 0) return -1;\n        }\n        if (arx !== brx) {\n          // are these two [almost] vertical segments with opposite orientation?\n          // if so, the one with the lower right endpoint comes first\n          const ay = ary - aly;\n          const ax = arx - alx;\n          const by = bry - bly;\n          const bx = brx - blx;\n          if (ay > ax && by < bx) return 1;\n          if (ay < ax && by > bx) return -1;\n        }\n\n        // we have colinear segments with matching orientation\n        // consider the one with more left-more right endpoint to be first\n        if (arx > brx) return 1;\n        if (arx < brx) return -1;\n\n        // if we get here, two two right endpoints are in the same\n        // vertical plane, ie arx === brx\n\n        // consider the lower right-endpoint to come first\n        if (ary < bry) return -1;\n        if (ary > bry) return 1;\n\n        // right endpoints identical as well, so the segments are idential\n        // fall back on creation order as consistent tie-breaker\n        if (a.id < b.id) return -1;\n        if (a.id > b.id) return 1;\n\n        // identical segment, ie a === b\n        return 0;\n      }\n\n      /* Warning: a reference to ringWindings input will be stored,\n       *  and possibly will be later modified */\n      constructor(leftSE, rightSE, rings, windings) {\n        this.id = ++segmentId;\n        this.leftSE = leftSE;\n        leftSE.segment = this;\n        leftSE.otherSE = rightSE;\n        this.rightSE = rightSE;\n        rightSE.segment = this;\n        rightSE.otherSE = leftSE;\n        this.rings = rings;\n        this.windings = windings;\n        // left unset for performance, set later in algorithm\n        // this.ringOut, this.consumedBy, this.prev\n      }\n      static fromRing(pt1, pt2, ring) {\n        let leftPt, rightPt, winding;\n\n        // ordering the two points according to sweep line ordering\n        const cmpPts = SweepEvent.comparePoints(pt1, pt2);\n        if (cmpPts < 0) {\n          leftPt = pt1;\n          rightPt = pt2;\n          winding = 1;\n        } else if (cmpPts > 0) {\n          leftPt = pt2;\n          rightPt = pt1;\n          winding = -1;\n        } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);\n        const leftSE = new SweepEvent(leftPt, true);\n        const rightSE = new SweepEvent(rightPt, false);\n        return new Segment(leftSE, rightSE, [ring], [winding]);\n      }\n\n      /* When a segment is split, the rightSE is replaced with a new sweep event */\n      replaceRightSE(newRightSE) {\n        this.rightSE = newRightSE;\n        this.rightSE.segment = this;\n        this.rightSE.otherSE = this.leftSE;\n        this.leftSE.otherSE = this.rightSE;\n      }\n      bbox() {\n        const y1 = this.leftSE.point.y;\n        const y2 = this.rightSE.point.y;\n        return {\n          ll: {\n            x: this.leftSE.point.x,\n            y: y1 < y2 ? y1 : y2\n          },\n          ur: {\n            x: this.rightSE.point.x,\n            y: y1 > y2 ? y1 : y2\n          }\n        };\n      }\n\n      /* A vector from the left point to the right */\n      vector() {\n        return {\n          x: this.rightSE.point.x - this.leftSE.point.x,\n          y: this.rightSE.point.y - this.leftSE.point.y\n        };\n      }\n      isAnEndpoint(pt) {\n        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n      }\n\n      /* Compare this segment with a point.\n       *\n       * A point P is considered to be colinear to a segment if there\n       * exists a distance D such that if we travel along the segment\n       * from one * endpoint towards the other a distance D, we find\n       * ourselves at point P.\n       *\n       * Return value indicates:\n       *\n       *   1: point lies above the segment (to the left of vertical)\n       *   0: point is colinear to segment\n       *  -1: point lies below the segment (to the right of vertical)\n       */\n      comparePoint(point) {\n        if (this.isAnEndpoint(point)) return 0;\n        const lPt = this.leftSE.point;\n        const rPt = this.rightSE.point;\n        const v = this.vector();\n\n        // Exactly vertical segments.\n        if (lPt.x === rPt.x) {\n          if (point.x === lPt.x) return 0;\n          return point.x < lPt.x ? 1 : -1;\n        }\n\n        // Nearly vertical segments with an intersection.\n        // Check to see where a point on the line with matching Y coordinate is.\n        const yDist = (point.y - lPt.y) / v.y;\n        const xFromYDist = lPt.x + yDist * v.x;\n        if (point.x === xFromYDist) return 0;\n\n        // General case.\n        // Check to see where a point on the line with matching X coordinate is.\n        const xDist = (point.x - lPt.x) / v.x;\n        const yFromXDist = lPt.y + xDist * v.y;\n        if (point.y === yFromXDist) return 0;\n        return point.y < yFromXDist ? -1 : 1;\n      }\n\n      /**\n       * Given another segment, returns the first non-trivial intersection\n       * between the two segments (in terms of sweep line ordering), if it exists.\n       *\n       * A 'non-trivial' intersection is one that will cause one or both of the\n       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n       *\n       *   * endpoint of segA with endpoint of segB --> trivial\n       *   * endpoint of segA with point along segB --> non-trivial\n       *   * endpoint of segB with point along segA --> non-trivial\n       *   * point along segA with point along segB --> non-trivial\n       *\n       * If no non-trivial intersection exists, return null\n       * Else, return null.\n       */\n      getIntersection(other) {\n        // If bboxes don't overlap, there can't be any intersections\n        const tBbox = this.bbox();\n        const oBbox = other.bbox();\n        const bboxOverlap = getBboxOverlap(tBbox, oBbox);\n        if (bboxOverlap === null) return null;\n\n        // We first check to see if the endpoints can be considered intersections.\n        // This will 'snap' intersections to endpoints if possible, and will\n        // handle cases of colinearity.\n\n        const tlp = this.leftSE.point;\n        const trp = this.rightSE.point;\n        const olp = other.leftSE.point;\n        const orp = other.rightSE.point;\n\n        // does each endpoint touch the other segment?\n        // note that we restrict the 'touching' definition to only allow segments\n        // to touch endpoints that lie forward from where we are in the sweep line pass\n        const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n        const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n        const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n        const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;\n\n        // do left endpoints match?\n        if (touchesThisLSE && touchesOtherLSE) {\n          // these two cases are for colinear segments with matching left\n          // endpoints, and one segment being longer than the other\n          if (touchesThisRSE && !touchesOtherRSE) return trp;\n          if (!touchesThisRSE && touchesOtherRSE) return orp;\n          // either the two segments match exactly (two trival intersections)\n          // or just on their left endpoint (one trivial intersection\n          return null;\n        }\n\n        // does this left endpoint matches (other doesn't)\n        if (touchesThisLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesOtherRSE) {\n            if (tlp.x === orp.x && tlp.y === orp.y) return null;\n          }\n          // t-intersection on left endpoint\n          return tlp;\n        }\n\n        // does other left endpoint matches (this doesn't)\n        if (touchesOtherLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesThisRSE) {\n            if (trp.x === olp.x && trp.y === olp.y) return null;\n          }\n          // t-intersection on left endpoint\n          return olp;\n        }\n\n        // trivial intersection on right endpoints\n        if (touchesThisRSE && touchesOtherRSE) return null;\n\n        // t-intersections on just one right endpoint\n        if (touchesThisRSE) return trp;\n        if (touchesOtherRSE) return orp;\n\n        // None of our endpoints intersect. Look for a general intersection between\n        // infinite lines laid over the segments\n        const pt = intersection$1(tlp, this.vector(), olp, other.vector());\n\n        // are the segments parrallel? Note that if they were colinear with overlap,\n        // they would have an endpoint intersection and that case was already handled above\n        if (pt === null) return null;\n\n        // is the intersection found between the lines not on the segments?\n        if (!isInBbox(bboxOverlap, pt)) return null;\n\n        // round the the computed point if needed\n        return rounder.round(pt.x, pt.y);\n      }\n\n      /**\n       * Split the given segment into multiple segments on the given points.\n       *  * Each existing segment will retain its leftSE and a new rightSE will be\n       *    generated for it.\n       *  * A new segment will be generated which will adopt the original segment's\n       *    rightSE, and a new leftSE will be generated for it.\n       *  * If there are more than two points given to split on, new segments\n       *    in the middle will be generated with new leftSE and rightSE's.\n       *  * An array of the newly generated SweepEvents will be returned.\n       *\n       * Warning: input array of points is modified\n       */\n      split(point) {\n        const newEvents = [];\n        const alreadyLinked = point.events !== undefined;\n        const newLeftSE = new SweepEvent(point, true);\n        const newRightSE = new SweepEvent(point, false);\n        const oldRightSE = this.rightSE;\n        this.replaceRightSE(newRightSE);\n        newEvents.push(newRightSE);\n        newEvents.push(newLeftSE);\n        const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());\n\n        // when splitting a nearly vertical downward-facing segment,\n        // sometimes one of the resulting new segments is vertical, in which\n        // case its left and right events may need to be swapped\n        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n          newSeg.swapEvents();\n        }\n        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n          this.swapEvents();\n        }\n\n        // in the point we just used to create new sweep events with was already\n        // linked to other events, we need to check if either of the affected\n        // segments should be consumed\n        if (alreadyLinked) {\n          newLeftSE.checkForConsuming();\n          newRightSE.checkForConsuming();\n        }\n        return newEvents;\n      }\n\n      /* Swap which event is left and right */\n      swapEvents() {\n        const tmpEvt = this.rightSE;\n        this.rightSE = this.leftSE;\n        this.leftSE = tmpEvt;\n        this.leftSE.isLeft = true;\n        this.rightSE.isLeft = false;\n        for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n          this.windings[i] *= -1;\n        }\n      }\n\n      /* Consume another segment. We take their rings under our wing\n       * and mark them as consumed. Use for perfectly overlapping segments */\n      consume(other) {\n        let consumer = this;\n        let consumee = other;\n        while (consumer.consumedBy) consumer = consumer.consumedBy;\n        while (consumee.consumedBy) consumee = consumee.consumedBy;\n        const cmp = Segment.compare(consumer, consumee);\n        if (cmp === 0) return; // already consumed\n        // the winner of the consumption is the earlier segment\n        // according to sweep line ordering\n        if (cmp > 0) {\n          const tmp = consumer;\n          consumer = consumee;\n          consumee = tmp;\n        }\n\n        // make sure a segment doesn't consume it's prev\n        if (consumer.prev === consumee) {\n          const tmp = consumer;\n          consumer = consumee;\n          consumee = tmp;\n        }\n        for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n          const ring = consumee.rings[i];\n          const winding = consumee.windings[i];\n          const index = consumer.rings.indexOf(ring);\n          if (index === -1) {\n            consumer.rings.push(ring);\n            consumer.windings.push(winding);\n          } else consumer.windings[index] += winding;\n        }\n        consumee.rings = null;\n        consumee.windings = null;\n        consumee.consumedBy = consumer;\n\n        // mark sweep events consumed as to maintain ordering in sweep event queue\n        consumee.leftSE.consumedBy = consumer.leftSE;\n        consumee.rightSE.consumedBy = consumer.rightSE;\n      }\n\n      /* The first segment previous segment chain that is in the result */\n      prevInResult() {\n        if (this._prevInResult !== undefined) return this._prevInResult;\n        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n        return this._prevInResult;\n      }\n      beforeState() {\n        if (this._beforeState !== undefined) return this._beforeState;\n        if (!this.prev) this._beforeState = {\n          rings: [],\n          windings: [],\n          multiPolys: []\n        };else {\n          const seg = this.prev.consumedBy || this.prev;\n          this._beforeState = seg.afterState();\n        }\n        return this._beforeState;\n      }\n      afterState() {\n        if (this._afterState !== undefined) return this._afterState;\n        const beforeState = this.beforeState();\n        this._afterState = {\n          rings: beforeState.rings.slice(0),\n          windings: beforeState.windings.slice(0),\n          multiPolys: []\n        };\n        const ringsAfter = this._afterState.rings;\n        const windingsAfter = this._afterState.windings;\n        const mpsAfter = this._afterState.multiPolys;\n\n        // calculate ringsAfter, windingsAfter\n        for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n          const ring = this.rings[i];\n          const winding = this.windings[i];\n          const index = ringsAfter.indexOf(ring);\n          if (index === -1) {\n            ringsAfter.push(ring);\n            windingsAfter.push(winding);\n          } else windingsAfter[index] += winding;\n        }\n\n        // calcualte polysAfter\n        const polysAfter = [];\n        const polysExclude = [];\n        for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n          if (windingsAfter[i] === 0) continue; // non-zero rule\n          const ring = ringsAfter[i];\n          const poly = ring.poly;\n          if (polysExclude.indexOf(poly) !== -1) continue;\n          if (ring.isExterior) polysAfter.push(poly);else {\n            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n            const index = polysAfter.indexOf(ring.poly);\n            if (index !== -1) polysAfter.splice(index, 1);\n          }\n        }\n\n        // calculate multiPolysAfter\n        for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n          const mp = polysAfter[i].multiPoly;\n          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n        }\n        return this._afterState;\n      }\n\n      /* Is this segment part of the final result? */\n      isInResult() {\n        // if we've been consumed, we're not in the result\n        if (this.consumedBy) return false;\n        if (this._isInResult !== undefined) return this._isInResult;\n        const mpsBefore = this.beforeState().multiPolys;\n        const mpsAfter = this.afterState().multiPolys;\n        switch (operation.type) {\n          case \"union\":\n            {\n              // UNION - included iff:\n              //  * On one side of us there is 0 poly interiors AND\n              //  * On the other side there is 1 or more.\n              const noBefores = mpsBefore.length === 0;\n              const noAfters = mpsAfter.length === 0;\n              this._isInResult = noBefores !== noAfters;\n              break;\n            }\n          case \"intersection\":\n            {\n              // INTERSECTION - included iff:\n              //  * on one side of us all multipolys are rep. with poly interiors AND\n              //  * on the other side of us, not all multipolys are repsented\n              //    with poly interiors\n              let least;\n              let most;\n              if (mpsBefore.length < mpsAfter.length) {\n                least = mpsBefore.length;\n                most = mpsAfter.length;\n              } else {\n                least = mpsAfter.length;\n                most = mpsBefore.length;\n              }\n              this._isInResult = most === operation.numMultiPolys && least < most;\n              break;\n            }\n          case \"xor\":\n            {\n              // XOR - included iff:\n              //  * the difference between the number of multipolys represented\n              //    with poly interiors on our two sides is an odd number\n              const diff = Math.abs(mpsBefore.length - mpsAfter.length);\n              this._isInResult = diff % 2 === 1;\n              break;\n            }\n          case \"difference\":\n            {\n              // DIFFERENCE included iff:\n              //  * on exactly one side, we have just the subject\n              const isJustSubject = mps => mps.length === 1 && mps[0].isSubject;\n              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n              break;\n            }\n          default:\n            throw new Error(`Unrecognized operation type found ${operation.type}`);\n        }\n        return this._isInResult;\n      }\n    }\n\n    class RingIn {\n      constructor(geomRing, poly, isExterior) {\n        if (!Array.isArray(geomRing) || geomRing.length === 0) {\n          throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        this.poly = poly;\n        this.isExterior = isExterior;\n        this.segments = [];\n        if (typeof geomRing[0][0] !== \"number\" || typeof geomRing[0][1] !== \"number\") {\n          throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n        this.bbox = {\n          ll: {\n            x: firstPoint.x,\n            y: firstPoint.y\n          },\n          ur: {\n            x: firstPoint.x,\n            y: firstPoint.y\n          }\n        };\n        let prevPoint = firstPoint;\n        for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n          if (typeof geomRing[i][0] !== \"number\" || typeof geomRing[i][1] !== \"number\") {\n            throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n          }\n          let point = rounder.round(geomRing[i][0], geomRing[i][1]);\n          // skip repeated points\n          if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n          this.segments.push(Segment.fromRing(prevPoint, point, this));\n          if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n          if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n          if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n          if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n          prevPoint = point;\n        }\n        // add segment from last to first if last is not the same as first\n        if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n          this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n        }\n      }\n      getSweepEvents() {\n        const sweepEvents = [];\n        for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n          const segment = this.segments[i];\n          sweepEvents.push(segment.leftSE);\n          sweepEvents.push(segment.rightSE);\n        }\n        return sweepEvents;\n      }\n    }\n    class PolyIn {\n      constructor(geomPoly, multiPoly) {\n        if (!Array.isArray(geomPoly)) {\n          throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        this.exteriorRing = new RingIn(geomPoly[0], this, true);\n        // copy by value\n        this.bbox = {\n          ll: {\n            x: this.exteriorRing.bbox.ll.x,\n            y: this.exteriorRing.bbox.ll.y\n          },\n          ur: {\n            x: this.exteriorRing.bbox.ur.x,\n            y: this.exteriorRing.bbox.ur.y\n          }\n        };\n        this.interiorRings = [];\n        for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n          const ring = new RingIn(geomPoly[i], this, false);\n          if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n          if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n          if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n          if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n          this.interiorRings.push(ring);\n        }\n        this.multiPoly = multiPoly;\n      }\n      getSweepEvents() {\n        const sweepEvents = this.exteriorRing.getSweepEvents();\n        for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          const ringSweepEvents = this.interiorRings[i].getSweepEvents();\n          for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(ringSweepEvents[j]);\n          }\n        }\n        return sweepEvents;\n      }\n    }\n    class MultiPolyIn {\n      constructor(geom, isSubject) {\n        if (!Array.isArray(geom)) {\n          throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        try {\n          // if the input looks like a polygon, convert it to a multipolygon\n          if (typeof geom[0][0][0] === \"number\") geom = [geom];\n        } catch (ex) {\n          // The input is either malformed or has empty arrays.\n          // In either case, it will be handled later on.\n        }\n        this.polys = [];\n        this.bbox = {\n          ll: {\n            x: Number.POSITIVE_INFINITY,\n            y: Number.POSITIVE_INFINITY\n          },\n          ur: {\n            x: Number.NEGATIVE_INFINITY,\n            y: Number.NEGATIVE_INFINITY\n          }\n        };\n        for (let i = 0, iMax = geom.length; i < iMax; i++) {\n          const poly = new PolyIn(geom[i], this);\n          if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n          if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n          if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n          if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n          this.polys.push(poly);\n        }\n        this.isSubject = isSubject;\n      }\n      getSweepEvents() {\n        const sweepEvents = [];\n        for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n          const polySweepEvents = this.polys[i].getSweepEvents();\n          for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(polySweepEvents[j]);\n          }\n        }\n        return sweepEvents;\n      }\n    }\n\n    class RingOut {\n      /* Given the segments from the sweep line pass, compute & return a series\n       * of closed rings from all the segments marked to be part of the result */\n      static factory(allSegments) {\n        const ringsOut = [];\n        for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n          const segment = allSegments[i];\n          if (!segment.isInResult() || segment.ringOut) continue;\n          let prevEvent = null;\n          let event = segment.leftSE;\n          let nextEvent = segment.rightSE;\n          const events = [event];\n          const startingPoint = event.point;\n          const intersectionLEs = [];\n\n          /* Walk the chain of linked events to form a closed ring */\n          while (true) {\n            prevEvent = event;\n            event = nextEvent;\n            events.push(event);\n\n            /* Is the ring complete? */\n            if (event.point === startingPoint) break;\n            while (true) {\n              const availableLEs = event.getAvailableLinkedEvents();\n\n              /* Did we hit a dead end? This shouldn't happen.\n               * Indicates some earlier part of the algorithm malfunctioned. */\n              if (availableLEs.length === 0) {\n                const firstPt = events[0].point;\n                const lastPt = events[events.length - 1].point;\n                throw new Error(`Unable to complete output ring starting at [${firstPt.x},` + ` ${firstPt.y}]. Last matching segment found ends at` + ` [${lastPt.x}, ${lastPt.y}].`);\n              }\n\n              /* Only one way to go, so cotinue on the path */\n              if (availableLEs.length === 1) {\n                nextEvent = availableLEs[0].otherSE;\n                break;\n              }\n\n              /* We must have an intersection. Check for a completed loop */\n              let indexLE = null;\n              for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n                if (intersectionLEs[j].point === event.point) {\n                  indexLE = j;\n                  break;\n                }\n              }\n              /* Found a completed loop. Cut that off and make a ring */\n              if (indexLE !== null) {\n                const intersectionLE = intersectionLEs.splice(indexLE)[0];\n                const ringEvents = events.splice(intersectionLE.index);\n                ringEvents.unshift(ringEvents[0].otherSE);\n                ringsOut.push(new RingOut(ringEvents.reverse()));\n                continue;\n              }\n              /* register the intersection */\n              intersectionLEs.push({\n                index: events.length,\n                point: event.point\n              });\n              /* Choose the left-most option to continue the walk */\n              const comparator = event.getLeftmostComparator(prevEvent);\n              nextEvent = availableLEs.sort(comparator)[0].otherSE;\n              break;\n            }\n          }\n          ringsOut.push(new RingOut(events));\n        }\n        return ringsOut;\n      }\n      constructor(events) {\n        this.events = events;\n        for (let i = 0, iMax = events.length; i < iMax; i++) {\n          events[i].segment.ringOut = this;\n        }\n        this.poly = null;\n      }\n      getGeom() {\n        // Remove superfluous points (ie extra points along a straight line),\n        let prevPt = this.events[0].point;\n        const points = [prevPt];\n        for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n          const pt = this.events[i].point;\n          const nextPt = this.events[i + 1].point;\n          if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue;\n          points.push(pt);\n          prevPt = pt;\n        }\n\n        // ring was all (within rounding error of angle calc) colinear points\n        if (points.length === 1) return null;\n\n        // check if the starting point is necessary\n        const pt = points[0];\n        const nextPt = points[1];\n        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n        points.push(points[0]);\n        const step = this.isExteriorRing() ? 1 : -1;\n        const iStart = this.isExteriorRing() ? 0 : points.length - 1;\n        const iEnd = this.isExteriorRing() ? points.length : -1;\n        const orderedPoints = [];\n        for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y]);\n        return orderedPoints;\n      }\n      isExteriorRing() {\n        if (this._isExteriorRing === undefined) {\n          const enclosing = this.enclosingRing();\n          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n        }\n        return this._isExteriorRing;\n      }\n      enclosingRing() {\n        if (this._enclosingRing === undefined) {\n          this._enclosingRing = this._calcEnclosingRing();\n        }\n        return this._enclosingRing;\n      }\n\n      /* Returns the ring that encloses this one, if any */\n      _calcEnclosingRing() {\n        // start with the ealier sweep line event so that the prevSeg\n        // chain doesn't lead us inside of a loop of ours\n        let leftMostEvt = this.events[0];\n        for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n          const evt = this.events[i];\n          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n        }\n        let prevSeg = leftMostEvt.segment.prevInResult();\n        let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        while (true) {\n          // no segment found, thus no ring can enclose us\n          if (!prevSeg) return null;\n\n          // no segments below prev segment found, thus the ring of the prev\n          // segment must loop back around and enclose us\n          if (!prevPrevSeg) return prevSeg.ringOut;\n\n          // if the two segments are of different rings, the ring of the prev\n          // segment must either loop around us or the ring of the prev prev\n          // seg, which would make us and the ring of the prev peers\n          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n              return prevSeg.ringOut;\n            } else return prevSeg.ringOut.enclosingRing();\n          }\n\n          // two segments are from the same ring, so this was a penisula\n          // of that ring. iterate downward, keep searching\n          prevSeg = prevPrevSeg.prevInResult();\n          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        }\n      }\n    }\n    class PolyOut {\n      constructor(exteriorRing) {\n        this.exteriorRing = exteriorRing;\n        exteriorRing.poly = this;\n        this.interiorRings = [];\n      }\n      addInterior(ring) {\n        this.interiorRings.push(ring);\n        ring.poly = this;\n      }\n      getGeom() {\n        const geom = [this.exteriorRing.getGeom()];\n        // exterior ring was all (within rounding error of angle calc) colinear points\n        if (geom[0] === null) return null;\n        for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          const ringGeom = this.interiorRings[i].getGeom();\n          // interior ring was all (within rounding error of angle calc) colinear points\n          if (ringGeom === null) continue;\n          geom.push(ringGeom);\n        }\n        return geom;\n      }\n    }\n    class MultiPolyOut {\n      constructor(rings) {\n        this.rings = rings;\n        this.polys = this._composePolys(rings);\n      }\n      getGeom() {\n        const geom = [];\n        for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n          const polyGeom = this.polys[i].getGeom();\n          // exterior ring was all (within rounding error of angle calc) colinear points\n          if (polyGeom === null) continue;\n          geom.push(polyGeom);\n        }\n        return geom;\n      }\n      _composePolys(rings) {\n        const polys = [];\n        for (let i = 0, iMax = rings.length; i < iMax; i++) {\n          const ring = rings[i];\n          if (ring.poly) continue;\n          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n            const enclosingRing = ring.enclosingRing();\n            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n            enclosingRing.poly.addInterior(ring);\n          }\n        }\n        return polys;\n      }\n    }\n\n    /**\n     * NOTE:  We must be careful not to change any segments while\n     *        they are in the SplayTree. AFAIK, there's no way to tell\n     *        the tree to rebalance itself - thus before splitting\n     *        a segment that's in the tree, we remove it from the tree,\n     *        do the split, then re-insert it. (Even though splitting a\n     *        segment *shouldn't* change its correct position in the\n     *        sweep line tree, the reality is because of rounding errors,\n     *        it sometimes does.)\n     */\n\n    class SweepLine {\n      constructor(queue) {\n        let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n        this.queue = queue;\n        this.tree = new Tree(comparator);\n        this.segments = [];\n      }\n      process(event) {\n        const segment = event.segment;\n        const newEvents = [];\n\n        // if we've already been consumed by another segment,\n        // clean up our body parts and get out\n        if (event.consumedBy) {\n          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n          return newEvents;\n        }\n        const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);\n        if (!node) throw new Error(`Unable to find segment #${segment.id} ` + `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` + `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` + \"in SweepLine tree.\");\n        let prevNode = node;\n        let nextNode = node;\n        let prevSeg = undefined;\n        let nextSeg = undefined;\n\n        // skip consumed segments still in tree\n        while (prevSeg === undefined) {\n          prevNode = this.tree.prev(prevNode);\n          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n        }\n\n        // skip consumed segments still in tree\n        while (nextSeg === undefined) {\n          nextNode = this.tree.next(nextNode);\n          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n        }\n        if (event.isLeft) {\n          // Check for intersections against the previous segment in the sweep line\n          let prevMySplitter = null;\n          if (prevSeg) {\n            const prevInter = prevSeg.getIntersection(segment);\n            if (prevInter !== null) {\n              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n              if (!prevSeg.isAnEndpoint(prevInter)) {\n                const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          }\n\n          // Check for intersections against the next segment in the sweep line\n          let nextMySplitter = null;\n          if (nextSeg) {\n            const nextInter = nextSeg.getIntersection(segment);\n            if (nextInter !== null) {\n              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n              if (!nextSeg.isAnEndpoint(nextInter)) {\n                const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          }\n\n          // For simplicity, even if we find more than one intersection we only\n          // spilt on the 'earliest' (sweep-line style) of the intersections.\n          // The other intersection will be handled in a future process().\n          if (prevMySplitter !== null || nextMySplitter !== null) {\n            let mySplitter = null;\n            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n              const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n            }\n\n            // Rounding errors can cause changes in ordering,\n            // so remove afected segments and right sweep events before splitting\n            this.queue.remove(segment.rightSE);\n            newEvents.push(segment.rightSE);\n            const newEventsFromSplit = segment.split(mySplitter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n          if (newEvents.length > 0) {\n            // We found some intersections, so re-do the current event to\n            // make sure sweep line ordering is totally consistent for later\n            // use with the segment 'prev' pointers\n            this.tree.remove(segment);\n            newEvents.push(event);\n          } else {\n            // done with left event\n            this.segments.push(segment);\n            segment.prev = prevSeg;\n          }\n        } else {\n          // event.isRight\n\n          // since we're about to be removed from the sweep line, check for\n          // intersections between our previous and next segments\n          if (prevSeg && nextSeg) {\n            const inter = prevSeg.getIntersection(nextSeg);\n            if (inter !== null) {\n              if (!prevSeg.isAnEndpoint(inter)) {\n                const newEventsFromSplit = this._splitSafely(prevSeg, inter);\n                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n              if (!nextSeg.isAnEndpoint(inter)) {\n                const newEventsFromSplit = this._splitSafely(nextSeg, inter);\n                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          }\n          this.tree.remove(segment);\n        }\n        return newEvents;\n      }\n\n      /* Safely split a segment that is currently in the datastructures\n       * IE - a segment other than the one that is currently being processed. */\n      _splitSafely(seg, pt) {\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        // removeNode() doesn't work, so have re-find the seg\n        // https://github.com/w8r/splay-tree/pull/5\n        this.tree.remove(seg);\n        const rightSE = seg.rightSE;\n        this.queue.remove(rightSE);\n        const newEvents = seg.split(pt);\n        newEvents.push(rightSE);\n        // splitting can trigger consumption\n        if (seg.consumedBy === undefined) this.tree.add(seg);\n        return newEvents;\n      }\n    }\n\n    // Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.\n    const POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\n    const POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\n    class Operation {\n      run(type, geom, moreGeoms) {\n        operation.type = type;\n        rounder.reset();\n\n        /* Convert inputs to MultiPoly objects */\n        const multipolys = [new MultiPolyIn(geom, true)];\n        for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n          multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n        }\n        operation.numMultiPolys = multipolys.length;\n\n        /* BBox optimization for difference operation\n         * If the bbox of a multipolygon that's part of the clipping doesn't\n         * intersect the bbox of the subject at all, we can just drop that\n         * multiploygon. */\n        if (operation.type === \"difference\") {\n          // in place removal\n          const subject = multipolys[0];\n          let i = 1;\n          while (i < multipolys.length) {\n            if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;else multipolys.splice(i, 1);\n          }\n        }\n\n        /* BBox optimization for intersection operation\n         * If we can find any pair of multipolygons whose bbox does not overlap,\n         * then the result will be empty. */\n        if (operation.type === \"intersection\") {\n          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n          //       it could be optimized to O(n * ln(n))\n          for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n            const mpA = multipolys[i];\n            for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n            }\n          }\n        }\n\n        /* Put segment endpoints in a priority queue */\n        const queue = new Tree(SweepEvent.compare);\n        for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n          const sweepEvents = multipolys[i].getSweepEvents();\n          for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n            queue.insert(sweepEvents[j]);\n            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n              // prevents an infinite loop, an otherwise common manifestation of bugs\n              throw new Error(\"Infinite loop when putting segment endpoints in a priority queue \" + \"(queue size too big).\");\n            }\n          }\n        }\n\n        /* Pass the sweep line over those endpoints */\n        const sweepLine = new SweepLine(queue);\n        let prevQueueSize = queue.size;\n        let node = queue.pop();\n        while (node) {\n          const evt = node.key;\n          if (queue.size === prevQueueSize) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            const seg = evt.segment;\n            throw new Error(`Unable to pop() ${evt.isLeft ? \"left\" : \"right\"} SweepEvent ` + `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` + `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` + `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);\n          }\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(queue size too big).\");\n          }\n          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(too many sweep line segments).\");\n          }\n          const newEvents = sweepLine.process(evt);\n          for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n            const evt = newEvents[i];\n            if (evt.consumedBy === undefined) queue.insert(evt);\n          }\n          prevQueueSize = queue.size;\n          node = queue.pop();\n        }\n\n        // free some memory we don't need anymore\n        rounder.reset();\n\n        /* Collect and compile segments we're keeping into a multipolygon */\n        const ringsOut = RingOut.factory(sweepLine.segments);\n        const result = new MultiPolyOut(ringsOut);\n        return result.getGeom();\n      }\n    }\n\n    // singleton available by import\n    const operation = new Operation();\n\n    const union = function (geom) {\n      for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        moreGeoms[_key - 1] = arguments[_key];\n      }\n      return operation.run(\"union\", geom, moreGeoms);\n    };\n    const intersection = function (geom) {\n      for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        moreGeoms[_key2 - 1] = arguments[_key2];\n      }\n      return operation.run(\"intersection\", geom, moreGeoms);\n    };\n    const xor = function (geom) {\n      for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        moreGeoms[_key3 - 1] = arguments[_key3];\n      }\n      return operation.run(\"xor\", geom, moreGeoms);\n    };\n    const difference = function (subjectGeom) {\n      for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        clippingGeoms[_key4 - 1] = arguments[_key4];\n      }\n      return operation.run(\"difference\", subjectGeom, clippingGeoms);\n    };\n    var index = {\n      union: union,\n      intersection: intersection,\n      xor: xor,\n      difference: difference\n    };\n\n    return index;\n\n}));\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = undefined;","// index.ts\nvar earthRadius = 63710088e-1;\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1e3,\n  kilometres: earthRadius / 1e3,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1e3,\n  millimetres: earthRadius * 1e3,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\nvar areaFactors = {\n  acres: 247105e-9,\n  centimeters: 1e4,\n  centimetres: 1e4,\n  feet: 10.763910417,\n  hectares: 1e-4,\n  inches: 1550.003100006,\n  kilometers: 1e-6,\n  kilometres: 1e-6,\n  meters: 1,\n  metres: 1,\n  miles: 386e-9,\n  nauticalmiles: 29155334959812285e-23,\n  millimeters: 1e6,\n  millimetres: 1e6,\n  yards: 1.195990046\n};\nfunction feature(geom, properties, options = {}) {\n  const feat = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\nfunction geometry(type, coordinates, _options = {}) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\nfunction point(coordinates, properties, options = {}) {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  const geom = {\n    type: \"Point\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction points(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\nfunction polygon(coordinates, properties, options = {}) {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom = {\n    type: \"Polygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction polygons(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\nfunction lineString(coordinates, properties, options = {}) {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom = {\n    type: \"LineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction lineStrings(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\nfunction featureCollection(features, options = {}) {\n  const fc = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\nfunction multiLineString(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiLineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPoint(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPoint\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPolygon(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPolygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction geometryCollection(geometries, properties, options = {}) {\n  const geom = {\n    type: \"GeometryCollection\",\n    geometries\n  };\n  return feature(geom, properties, options);\n}\nfunction round(num, precision = 0) {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\nfunction radiansToLength(radians, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\nfunction lengthToRadians(distance, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\nfunction bearingToAzimuth(bearing) {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\nfunction azimuthToBearing(angle) {\n  angle = angle % 360;\n  if (angle > 0)\n    return angle > 180 ? angle - 360 : angle;\n  return angle < -180 ? angle + 360 : angle;\n}\nfunction radiansToDegrees(radians) {\n  const degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\nfunction degreesToRadians(degrees) {\n  const radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\nfunction convertLength(length, originalUnit = \"kilometers\", finalUnit = \"kilometers\") {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nfunction convertArea(area, originalUnit = \"meters\", finalUnit = \"kilometers\") {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nfunction isObject(input) {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\nexport {\n  areaFactors,\n  azimuthToBearing,\n  bearingToAzimuth,\n  convertArea,\n  convertLength,\n  degreesToRadians,\n  earthRadius,\n  factors,\n  feature,\n  featureCollection,\n  geometry,\n  geometryCollection,\n  isNumber,\n  isObject,\n  lengthToDegrees,\n  lengthToRadians,\n  lineString,\n  lineStrings,\n  multiLineString,\n  multiPoint,\n  multiPolygon,\n  point,\n  points,\n  polygon,\n  polygons,\n  radiansToDegrees,\n  radiansToLength,\n  round,\n  validateBBox,\n  validateId\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { polygon } from \"@turf/helpers\";\nfunction bboxPolygon(bbox, options = {}) {\n  const west = Number(bbox[0]);\n  const south = Number(bbox[1]);\n  const east = Number(bbox[2]);\n  const north = Number(bbox[3]);\n  if (bbox.length === 6) {\n    throw new Error(\n      \"@turf/bbox-polygon does not support BBox with 6 positions\"\n    );\n  }\n  const lowLeft = [west, south];\n  const topLeft = [west, north];\n  const topRight = [east, north];\n  const lowRight = [east, south];\n  return polygon(\n    [[lowLeft, lowRight, topRight, topLeft, lowLeft]],\n    options.properties,\n    { bbox, id: options.id }\n  );\n}\nvar turf_bbox_polygon_default = bboxPolygon;\nexport {\n  bboxPolygon,\n  turf_bbox_polygon_default as default\n};\n//# sourceMappingURL=index.js.map","function pointInPolygon(p, polygon) {\n    var i = 0;\n    var ii = 0;\n    var k = 0;\n    var f = 0;\n    var u1 = 0;\n    var v1 = 0;\n    var u2 = 0;\n    var v2 = 0;\n    var currentP = null;\n    var nextP = null;\n\n    var x = p[0];\n    var y = p[1];\n\n    var numContours = polygon.length;\n    for (i; i < numContours; i++) {\n        ii = 0;\n        var contourLen = polygon[i].length - 1;\n        var contour = polygon[i];\n\n        currentP = contour[0];\n        if (currentP[0] !== contour[contourLen][0] &&\n            currentP[1] !== contour[contourLen][1]) {\n            throw new Error('First and last coordinates in a ring must be the same')\n        }\n\n        u1 = currentP[0] - x;\n        v1 = currentP[1] - y;\n\n        for (ii; ii < contourLen; ii++) {\n            nextP = contour[ii + 1];\n\n            v2 = nextP[1] - y;\n\n            if ((v1 < 0 && v2 < 0) || (v1 > 0 && v2 > 0)) {\n                currentP = nextP;\n                v1 = v2;\n                u1 = currentP[0] - x;\n                continue\n            }\n\n            u2 = nextP[0] - p[0];\n\n            if (v2 > 0 && v1 <= 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f > 0) { k = k + 1; }\n                else if (f === 0) { return 0 }\n            } else if (v1 > 0 && v2 <= 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f < 0) { k = k + 1; }\n                else if (f === 0) { return 0 }\n            } else if (v2 === 0 && v1 < 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f === 0) { return 0 }\n            } else if (v1 === 0 && v2 < 0) {\n                f = u1 * v2 - u2 * v1;\n                if (f === 0) { return 0 }\n            } else if (v1 === 0 && v2 === 0) {\n                if (u2 <= 0 && u1 >= 0) {\n                    return 0\n                } else if (u1 <= 0 && u2 >= 0) {\n                    return 0\n                }\n            }\n            currentP = nextP;\n            v1 = v2;\n            u1 = u2;\n        }\n    }\n\n    if (k % 2 === 0) { return false }\n    return true\n}\n\nexport default pointInPolygon;\n","// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport pip from \"point-in-polygon-hao\";\nimport { getCoord, getGeom } from \"@turf/invariant\";\nfunction booleanPointInPolygon(point, polygon, options = {}) {\n  if (!point) {\n    throw new Error(\"point is required\");\n  }\n  if (!polygon) {\n    throw new Error(\"polygon is required\");\n  }\n  const pt = getCoord(point);\n  const geom = getGeom(polygon);\n  const type = geom.type;\n  const bbox = polygon.bbox;\n  let polys = geom.coordinates;\n  if (bbox && inBBox(pt, bbox) === false) {\n    return false;\n  }\n  if (type === \"Polygon\") {\n    polys = [polys];\n  }\n  let result = false;\n  for (var i = 0; i < polys.length; ++i) {\n    const polyResult = pip(pt, polys[i]);\n    if (polyResult === 0)\n      return options.ignoreBoundary ? false : true;\n    else if (polyResult)\n      result = true;\n  }\n  return result;\n}\nfunction inBBox(pt, bbox) {\n  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n}\nvar turf_boolean_point_in_polygon_default = booleanPointInPolygon;\nexport {\n  booleanPointInPolygon,\n  turf_boolean_point_in_polygon_default as default\n};\n//# sourceMappingURL=index.js.map","class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction checkWhichEventIsLeft (e1, e2) {\n    if (e1.p.x > e2.p.x) return 1\n    if (e1.p.x < e2.p.x) return -1\n\n    if (e1.p.y !== e2.p.y) return e1.p.y > e2.p.y ? 1 : -1\n    return 1\n}\n\nfunction checkWhichSegmentHasRightEndpointFirst (seg1, seg2) {\n    if (seg1.rightSweepEvent.p.x > seg2.rightSweepEvent.p.x) return 1\n    if (seg1.rightSweepEvent.p.x < seg2.rightSweepEvent.p.x) return -1\n\n    if (seg1.rightSweepEvent.p.y !== seg2.rightSweepEvent.p.y) return seg1.rightSweepEvent.p.y < seg2.rightSweepEvent.p.y ? 1 : -1\n    return 1\n}\n\nclass Event {\n\n    constructor (p, featureId, ringId, eventId) {\n        this.p = {\n            x: p[0],\n            y: p[1]\n        };\n        this.featureId = featureId;\n        this.ringId = ringId;\n        this.eventId = eventId;\n\n        this.otherEvent = null;\n        this.isLeftEndpoint = null;\n    }\n\n    isSamePoint (eventToCheck) {\n        return this.p.x === eventToCheck.p.x && this.p.y === eventToCheck.p.y\n    }\n}\n\nfunction fillEventQueue (geojson, eventQueue) {\n    if (geojson.type === 'FeatureCollection') {\n        const features = geojson.features;\n        for (let i = 0; i < features.length; i++) {\n            processFeature(features[i], eventQueue);\n        }\n    } else {\n        processFeature(geojson, eventQueue);\n    }\n}\n\nlet featureId = 0;\nlet ringId = 0;\nlet eventId = 0;\nfunction processFeature (featureOrGeometry, eventQueue) {\n    const geom = featureOrGeometry.type === 'Feature' ? featureOrGeometry.geometry : featureOrGeometry;\n    let coords = geom.coordinates;\n    // standardise the input\n    if (geom.type === 'Polygon' || geom.type === 'MultiLineString') coords = [coords];\n    if (geom.type === 'LineString') coords = [[coords]];\n\n    for (let i = 0; i < coords.length; i++) {\n        for (let ii = 0; ii < coords[i].length; ii++) {\n            let currentP = coords[i][ii][0];\n            let nextP = null;\n            ringId = ringId + 1;\n            for (let iii = 0; iii < coords[i][ii].length - 1; iii++) {\n                nextP = coords[i][ii][iii + 1];\n\n                const e1 = new Event(currentP, featureId, ringId, eventId);\n                const e2 = new Event(nextP, featureId, ringId, eventId + 1);\n\n                e1.otherEvent = e2;\n                e2.otherEvent = e1;\n\n                if (checkWhichEventIsLeft(e1, e2) > 0) {\n                    e2.isLeftEndpoint = true;\n                    e1.isLeftEndpoint = false;\n                } else {\n                    e1.isLeftEndpoint = true;\n                    e2.isLeftEndpoint = false;\n                }\n                eventQueue.push(e1);\n                eventQueue.push(e2);\n\n                currentP = nextP;\n                eventId = eventId + 1;\n            }\n        }\n    }\n    featureId = featureId + 1;\n}\n\nclass Segment {\n\n    constructor (event) {\n        this.leftSweepEvent = event;\n        this.rightSweepEvent = event.otherEvent;\n    }\n}\n\nfunction testSegmentIntersect (seg1, seg2) {\n    if (seg1 === null || seg2 === null) return false\n\n    if (seg1.leftSweepEvent.ringId === seg2.leftSweepEvent.ringId &&\n        (seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.rightSweepEvent.isSamePoint(seg2.rightSweepEvent) ||\n        seg1.leftSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.leftSweepEvent.isSamePoint(seg2.rightSweepEvent))) return false\n\n    const x1 = seg1.leftSweepEvent.p.x;\n    const y1 = seg1.leftSweepEvent.p.y;\n    const x2 = seg1.rightSweepEvent.p.x;\n    const y2 = seg1.rightSweepEvent.p.y;\n    const x3 = seg2.leftSweepEvent.p.x;\n    const y3 = seg2.leftSweepEvent.p.y;\n    const x4 = seg2.rightSweepEvent.p.x;\n    const y4 = seg2.rightSweepEvent.p.y;\n\n    const denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    const numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    const numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) return false\n        return false\n    }\n\n    const uA = numeA / denom;\n    const uB = numeB / denom;\n\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        const x = x1 + (uA * (x2 - x1));\n        const y = y1 + (uA * (y2 - y1));\n        return [x, y]\n    }\n    return false\n}\n\n// import {debugEventAndSegments, debugRemovingSegment} from './debug'\n\nfunction runCheck (eventQueue, ignoreSelfIntersections) {\n    ignoreSelfIntersections = ignoreSelfIntersections ? ignoreSelfIntersections : false;\n\n    const intersectionPoints = [];\n    const outQueue = new TinyQueue([], checkWhichSegmentHasRightEndpointFirst);\n\n    while (eventQueue.length) {\n        const event = eventQueue.pop();\n        if (event.isLeftEndpoint) {\n            // debugEventAndSegments(event.p, outQueue.data)\n            const segment = new Segment(event);\n            for (let i = 0; i < outQueue.data.length; i++) {\n                const otherSeg = outQueue.data[i];\n                if (ignoreSelfIntersections) {\n                    if (otherSeg.leftSweepEvent.featureId === event.featureId) continue\n                }\n                const intersection = testSegmentIntersect(segment, otherSeg);\n                if (intersection !== false) intersectionPoints.push(intersection);\n            }\n            outQueue.push(segment);\n        } else if (event.isLeftEndpoint === false) {\n            outQueue.pop();\n            // const seg = outQueue.pop()\n            // debugRemovingSegment(event.p, seg)\n        }\n    }\n    return intersectionPoints\n}\n\nfunction sweeplineIntersections (geojson, ignoreSelfIntersections) {\n    const eventQueue = new TinyQueue([], checkWhichEventIsLeft);\n    fillEventQueue(geojson, eventQueue);\n    return runCheck(eventQueue, ignoreSelfIntersections)\n}\n\nexport default sweeplineIntersections;\n","// index.ts\nimport { feature, featureCollection, point } from \"@turf/helpers\";\n\n// lib/sweepline-intersections-export.ts\nimport lib from \"sweepline-intersections\";\nvar sweeplineIntersections = lib;\n\n// index.ts\nfunction lineIntersect(line1, line2, options = {}) {\n  const { removeDuplicates = true, ignoreSelfIntersections = false } = options;\n  let features = [];\n  if (line1.type === \"FeatureCollection\")\n    features = features.concat(line1.features);\n  else if (line1.type === \"Feature\")\n    features.push(line1);\n  else if (line1.type === \"LineString\" || line1.type === \"Polygon\" || line1.type === \"MultiLineString\" || line1.type === \"MultiPolygon\") {\n    features.push(feature(line1));\n  }\n  if (line2.type === \"FeatureCollection\")\n    features = features.concat(line2.features);\n  else if (line2.type === \"Feature\")\n    features.push(line2);\n  else if (line2.type === \"LineString\" || line2.type === \"Polygon\" || line2.type === \"MultiLineString\" || line2.type === \"MultiPolygon\") {\n    features.push(feature(line2));\n  }\n  const intersections = sweeplineIntersections(\n    featureCollection(features),\n    ignoreSelfIntersections\n  );\n  let results = [];\n  if (removeDuplicates) {\n    const unique = {};\n    intersections.forEach((intersection) => {\n      const key = intersection.join(\",\");\n      if (!unique[key]) {\n        unique[key] = true;\n        results.push(intersection);\n      }\n    });\n  } else {\n    results = intersections;\n  }\n  return featureCollection(results.map((r) => point(r)));\n}\nvar turf_line_intersect_default = lineIntersect;\nexport {\n  turf_line_intersect_default as default,\n  lineIntersect\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null)\n    return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null)\n        continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\")\n              multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\")\n            multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\")\n              multiFeatureIndex++;\n            if (geomType === \"Polygon\")\n              geometryIndex++;\n          }\n          if (geomType === \"Polygon\")\n            multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false)\n          break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false)\n        break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else\n      previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry)\n      return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\")\n      return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson)\n    throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null)\n      return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options))\n    throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null)\n    return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0)\n        segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0)\n        geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options))\n    throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null)\n    return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0)\n        coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0)\n        geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\nfunction polygonToLine(poly, options = {}) {\n  const geom = getGeom(poly);\n  if (!options.properties && poly.type === \"Feature\") {\n    options.properties = poly.properties;\n  }\n  switch (geom.type) {\n    case \"Polygon\":\n      return singlePolygonToLine(geom, options);\n    case \"MultiPolygon\":\n      return multiPolygonToLine(geom, options);\n    default:\n      throw new Error(\"invalid poly\");\n  }\n}\nfunction singlePolygonToLine(poly, options = {}) {\n  const geom = getGeom(poly);\n  const coords = geom.coordinates;\n  const properties = options.properties ? options.properties : poly.type === \"Feature\" ? poly.properties : {};\n  return coordsToLine(coords, properties);\n}\nfunction multiPolygonToLine(multiPoly, options = {}) {\n  const geom = getGeom(multiPoly);\n  const coords = geom.coordinates;\n  const properties = options.properties ? options.properties : multiPoly.type === \"Feature\" ? multiPoly.properties : {};\n  const lines = [];\n  coords.forEach((coord) => {\n    lines.push(coordsToLine(coord, properties));\n  });\n  return featureCollection(lines);\n}\nfunction coordsToLine(coords, properties) {\n  if (coords.length > 1) {\n    return multiLineString(coords, properties);\n  }\n  return lineString(coords[0], properties);\n}\nvar turf_polygon_to_line_default = polygonToLine;\nexport {\n  coordsToLine,\n  turf_polygon_to_line_default as default,\n  multiPolygonToLine,\n  polygonToLine,\n  singlePolygonToLine\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\nfunction booleanDisjoint(feature1, feature2, options = {}) {\n  var _a;\n  const ignoreSelfIntersections = (_a = options.ignoreSelfIntersections) != null ? _a : false;\n  let bool = true;\n  flattenEach(feature1, (flatten1) => {\n    flattenEach(feature2, (flatten2) => {\n      if (bool === false) {\n        return false;\n      }\n      bool = disjoint(\n        flatten1.geometry,\n        flatten2.geometry,\n        ignoreSelfIntersections\n      );\n    });\n  });\n  return bool;\n}\nfunction disjoint(geom1, geom2, ignoreSelfIntersections) {\n  switch (geom1.type) {\n    case \"Point\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !compareCoords(geom1.coordinates, geom2.coordinates);\n        case \"LineString\":\n          return !isPointOnLine(geom2, geom1);\n        case \"Polygon\":\n          return !booleanPointInPolygon(geom1, geom2);\n      }\n      break;\n    case \"LineString\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !isPointOnLine(geom1, geom2);\n        case \"LineString\":\n          return !isLineOnLine(geom1, geom2, ignoreSelfIntersections);\n        case \"Polygon\":\n          return !isLineInPoly(geom2, geom1, ignoreSelfIntersections);\n      }\n      break;\n    case \"Polygon\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !booleanPointInPolygon(geom2, geom1);\n        case \"LineString\":\n          return !isLineInPoly(geom1, geom2, ignoreSelfIntersections);\n        case \"Polygon\":\n          return !isPolyInPoly(geom2, geom1, ignoreSelfIntersections);\n      }\n  }\n  return false;\n}\nfunction isPointOnLine(lineString, pt) {\n  for (let i = 0; i < lineString.coordinates.length - 1; i++) {\n    if (isPointOnLineSegment(\n      lineString.coordinates[i],\n      lineString.coordinates[i + 1],\n      pt.coordinates\n    )) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isLineOnLine(lineString1, lineString2, ignoreSelfIntersections) {\n  const doLinesIntersect = lineIntersect(lineString1, lineString2, {\n    ignoreSelfIntersections\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isLineInPoly(polygon, lineString, ignoreSelfIntersections) {\n  for (const coord of lineString.coordinates) {\n    if (booleanPointInPolygon(coord, polygon)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon), {\n    ignoreSelfIntersections\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isPolyInPoly(feature1, feature2, ignoreSelfIntersections) {\n  for (const coord1 of feature1.coordinates[0]) {\n    if (booleanPointInPolygon(coord1, feature2)) {\n      return true;\n    }\n  }\n  for (const coord2 of feature2.coordinates[0]) {\n    if (booleanPointInPolygon(coord2, feature1)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(\n    polygonToLine(feature1),\n    polygonToLine(feature2),\n    { ignoreSelfIntersections }\n  );\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n  const dxc = pt[0] - lineSegmentStart[0];\n  const dyc = pt[1] - lineSegmentStart[1];\n  const dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n  const dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n  const cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) {\n    return false;\n  }\n  if (Math.abs(dxl) >= Math.abs(dyl)) {\n    if (dxl > 0) {\n      return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n    } else {\n      return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n    }\n  } else if (dyl > 0) {\n    return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n  } else {\n    return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n  }\n}\nfunction compareCoords(pair1, pair2) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nvar turf_boolean_disjoint_default = booleanDisjoint;\nexport {\n  booleanDisjoint,\n  turf_boolean_disjoint_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians } from \"@turf/helpers\";\nfunction distance(from, to, options = {}) {\n  var coordinates1 = getCoord(from);\n  var coordinates2 = getCoord(to);\n  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n  var lat1 = degreesToRadians(coordinates1[1]);\n  var lat2 = degreesToRadians(coordinates2[1]);\n  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n  return radiansToLength(\n    2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),\n    options.units\n  );\n}\nvar turf_distance_default = distance;\nexport {\n  turf_distance_default as default,\n  distance\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nfunction bearing(start, end, options = {}) {\n  if (options.final === true) {\n    return calculateFinalBearing(start, end);\n  }\n  const coordinates1 = getCoord(start);\n  const coordinates2 = getCoord(end);\n  const lon1 = degreesToRadians(coordinates1[0]);\n  const lon2 = degreesToRadians(coordinates2[0]);\n  const lat1 = degreesToRadians(coordinates1[1]);\n  const lat2 = degreesToRadians(coordinates2[1]);\n  const a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  const b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n  return radiansToDegrees(Math.atan2(a, b));\n}\nfunction calculateFinalBearing(start, end) {\n  let bear = bearing(end, start);\n  bear = (bear + 180) % 360;\n  return bear;\n}\nvar turf_bearing_default = bearing;\nexport {\n  bearing,\n  turf_bearing_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport {\n  degreesToRadians,\n  lengthToRadians,\n  point,\n  radiansToDegrees\n} from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nfunction destination(origin, distance, bearing, options = {}) {\n  const coordinates1 = getCoord(origin);\n  const longitude1 = degreesToRadians(coordinates1[0]);\n  const latitude1 = degreesToRadians(coordinates1[1]);\n  const bearingRad = degreesToRadians(bearing);\n  const radians = lengthToRadians(distance, options.units);\n  const latitude2 = Math.asin(\n    Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad)\n  );\n  const longitude2 = longitude1 + Math.atan2(\n    Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),\n    Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2)\n  );\n  const lng = radiansToDegrees(longitude2);\n  const lat = radiansToDegrees(latitude2);\n  return point([lng, lat], options.properties);\n}\nvar turf_destination_default = destination;\nexport {\n  turf_destination_default as default,\n  destination\n};\n//# sourceMappingURL=index.js.map","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// index.ts\nimport { bearing } from \"@turf/bearing\";\nimport { distance } from \"@turf/distance\";\nimport { destination } from \"@turf/destination\";\nimport { lineIntersect as lineIntersects } from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, lineString } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nfunction nearestPointOnLine(lines, pt, options = {}) {\n  if (!lines || !pt) {\n    throw new Error(\"lines and pt are required arguments\");\n  }\n  let closestPt = point([Infinity, Infinity], {\n    dist: Infinity,\n    index: -1,\n    multiFeatureIndex: -1,\n    location: -1\n  });\n  let length = 0;\n  flattenEach(\n    lines,\n    function(line, _featureIndex, multiFeatureIndex) {\n      const coords = getCoords(line);\n      for (let i = 0; i < coords.length - 1; i++) {\n        const start = point(coords[i]);\n        start.properties.dist = distance(pt, start, options);\n        const stop = point(coords[i + 1]);\n        stop.properties.dist = distance(pt, stop, options);\n        const sectionLength = distance(start, stop, options);\n        const heightDistance = Math.max(\n          start.properties.dist,\n          stop.properties.dist\n        );\n        const direction = bearing(start, stop);\n        const perpendicularPt1 = destination(\n          pt,\n          heightDistance,\n          direction + 90,\n          options\n        );\n        const perpendicularPt2 = destination(\n          pt,\n          heightDistance,\n          direction - 90,\n          options\n        );\n        const intersect = lineIntersects(\n          lineString([\n            perpendicularPt1.geometry.coordinates,\n            perpendicularPt2.geometry.coordinates\n          ]),\n          lineString([start.geometry.coordinates, stop.geometry.coordinates])\n        );\n        let intersectPt;\n        if (intersect.features.length > 0 && intersect.features[0]) {\n          intersectPt = __spreadProps(__spreadValues({}, intersect.features[0]), {\n            properties: {\n              dist: distance(pt, intersect.features[0], options),\n              multiFeatureIndex,\n              location: length + distance(start, intersect.features[0], options)\n            }\n          });\n        }\n        if (start.properties.dist < closestPt.properties.dist) {\n          closestPt = __spreadProps(__spreadValues({}, start), {\n            properties: __spreadProps(__spreadValues({}, start.properties), {\n              index: i,\n              multiFeatureIndex,\n              location: length\n            })\n          });\n        }\n        if (stop.properties.dist < closestPt.properties.dist) {\n          closestPt = __spreadProps(__spreadValues({}, stop), {\n            properties: __spreadProps(__spreadValues({}, stop.properties), {\n              index: i + 1,\n              multiFeatureIndex,\n              location: length + sectionLength\n            })\n          });\n        }\n        if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n          closestPt = __spreadProps(__spreadValues({}, intersectPt), {\n            properties: __spreadProps(__spreadValues({}, intersectPt.properties), { index: i })\n          });\n        }\n        length += sectionLength;\n      }\n    }\n  );\n  return closestPt;\n}\nvar turf_nearest_point_on_line_default = nearestPointOnLine;\nexport {\n  turf_nearest_point_on_line_default as default,\n  nearestPointOnLine\n};\n//# sourceMappingURL=index.js.map","// index.ts\nfunction clone(geojson) {\n  if (!geojson) {\n    throw new Error(\"geojson is required\");\n  }\n  switch (geojson.type) {\n    case \"Feature\":\n      return cloneFeature(geojson);\n    case \"FeatureCollection\":\n      return cloneFeatureCollection(geojson);\n    case \"Point\":\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiPoint\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n    case \"GeometryCollection\":\n      return cloneGeometry(geojson);\n    default:\n      throw new Error(\"unknown GeoJSON type\");\n  }\n}\nfunction cloneFeature(geojson) {\n  const cloned = { type: \"Feature\" };\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"properties\":\n      case \"geometry\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  cloned.properties = cloneProperties(geojson.properties);\n  if (geojson.geometry == null) {\n    cloned.geometry = null;\n  } else {\n    cloned.geometry = cloneGeometry(geojson.geometry);\n  }\n  return cloned;\n}\nfunction cloneProperties(properties) {\n  const cloned = {};\n  if (!properties) {\n    return cloned;\n  }\n  Object.keys(properties).forEach((key) => {\n    const value = properties[key];\n    if (typeof value === \"object\") {\n      if (value === null) {\n        cloned[key] = null;\n      } else if (Array.isArray(value)) {\n        cloned[key] = value.map((item) => {\n          return item;\n        });\n      } else {\n        cloned[key] = cloneProperties(value);\n      }\n    } else {\n      cloned[key] = value;\n    }\n  });\n  return cloned;\n}\nfunction cloneFeatureCollection(geojson) {\n  const cloned = { type: \"FeatureCollection\" };\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"features\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  cloned.features = geojson.features.map((feature) => {\n    return cloneFeature(feature);\n  });\n  return cloned;\n}\nfunction cloneGeometry(geometry) {\n  const geom = { type: geometry.type };\n  if (geometry.bbox) {\n    geom.bbox = geometry.bbox;\n  }\n  if (geometry.type === \"GeometryCollection\") {\n    geom.geometries = geometry.geometries.map((g) => {\n      return cloneGeometry(g);\n    });\n    return geom;\n  }\n  geom.coordinates = deepSlice(geometry.coordinates);\n  return geom;\n}\nfunction deepSlice(coords) {\n  const cloned = coords;\n  if (typeof cloned[0] !== \"object\") {\n    return cloned.slice();\n  }\n  return cloned.map((coord) => {\n    return deepSlice(coord);\n  });\n}\nvar turf_clone_default = clone;\nexport {\n  clone,\n  cloneProperties,\n  turf_clone_default as default\n};\n//# sourceMappingURL=index.js.map","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// index.ts\nimport { clone } from \"@turf/clone\";\nimport { distance } from \"@turf/distance\";\nimport { featureEach } from \"@turf/meta\";\nfunction nearestPoint(targetPoint, points, options = {}) {\n  if (!targetPoint)\n    throw new Error(\"targetPoint is required\");\n  if (!points)\n    throw new Error(\"points is required\");\n  let minDist = Infinity;\n  let bestFeatureIndex = 0;\n  featureEach(points, (pt, featureIndex) => {\n    const distanceToPoint = distance(targetPoint, pt, options);\n    if (distanceToPoint < minDist) {\n      bestFeatureIndex = featureIndex;\n      minDist = distanceToPoint;\n    }\n  });\n  const nearestPoint2 = clone(points.features[bestFeatureIndex]);\n  return __spreadProps(__spreadValues({}, nearestPoint2), {\n    properties: __spreadProps(__spreadValues({}, nearestPoint2.properties), {\n      featureIndex: bestFeatureIndex,\n      distanceToPoint: minDist\n    })\n  });\n}\nvar turf_nearest_point_default = nearestPoint;\nexport {\n  turf_nearest_point_default as default,\n  nearestPoint\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { bearing } from \"@turf/bearing\";\nimport { destination } from \"@turf/destination\";\nimport { distance } from \"@turf/distance\";\nfunction midpoint(point1, point2) {\n  const dist = distance(point1, point2);\n  const heading = bearing(point1, point2);\n  const midpoint2 = destination(point1, dist / 2, heading);\n  return midpoint2;\n}\nvar turf_midpoint_default = midpoint;\nexport {\n  turf_midpoint_default as default,\n  midpoint\n};\n//# sourceMappingURL=index.js.map","// Heavily inspired from work of @davidgilbertson on Github and `leaflet-geoman` project.\nimport MapboxDraw from \"@mapbox/mapbox-gl-draw\";\n\nconst { geojsonTypes } = MapboxDraw.constants;\n\nimport bboxPolygon from \"@turf/bbox-polygon\";\nimport booleanDisjoint from \"@turf/boolean-disjoint\";\nimport { getCoords } from \"@turf/invariant\";\nimport distance from \"@turf/distance\";\nimport polygonToLine from \"@turf/polygon-to-line\";\nimport nearestPointOnLine from \"@turf/nearest-point-on-line\";\nimport nearestPointInPointSet from \"@turf/nearest-point\";\nimport midpoint from \"@turf/midpoint\";\nimport {\n  featureCollection,\n  lineString as turfLineString,\n  point as turfPoint,\n} from \"@turf/helpers\";\nimport { LngLatLike, Map } from \"mapbox-gl\";\n\nexport const IDS = {\n  VERTICAL_GUIDE: \"VERTICAL_GUIDE\",\n  HORIZONTAL_GUIDE: \"HORIZONTAL_GUIDE\",\n};\n\nexport const addPointTovertices = (\n  map: Map,\n  vertices: any,\n  coordinates: LngLatLike,\n  forceInclusion?: boolean\n) => {\n  const { width: w, height: h } = map.getCanvas();\n  // Just add verteices of features currently visible in viewport\n  const { x, y } = map.project(coordinates);\n  const pointIsOnTheScreen = x > 0 && x < w && y > 0 && y < h;\n\n  // But do add off-screen points if forced (e.g. for the current feature)\n  // So features will always snap to their own points\n  if (pointIsOnTheScreen || forceInclusion) {\n    vertices.push(coordinates);\n  }\n};\n\nexport const createSnapList = (\n  map: Map,\n  draw: MapboxDraw,\n  currentFeature: MapboxDraw.DrawFeature,\n  sourcesIds: string[] = []\n) => {\n  // get all features from user's sources\n  const sourcesFeatures = sourcesIds\n    .map((id) => {\n      const source = map.getSource(id);\n      if (source?.type === \"geojson\") {\n        const sourceData = source._data;\n        if (!sourceData || typeof sourceData === \"string\") return [];\n\n        if (sourceData.type === \"FeatureCollection\") {\n          return sourceData.features;\n        } else if (sourceData.type === \"Feature\") {\n          return [sourceData];\n        }\n\n        return [];\n      }\n      return [];\n    })\n    .flat();\n\n  // Get all drawn features and sources features\n  const features = draw.getAll().features.concat(sourcesFeatures);\n  const snapList: GeoJSON.Feature[] = [];\n\n  // Get current bbox as polygon\n  const bboxAsPolygon = (() => {\n    const canvas = map.getCanvas(),\n      w = canvas.width,\n      h = canvas.height,\n      cUL = map.unproject([0, 0]).toArray(),\n      cUR = map.unproject([w, 0]).toArray(),\n      cLR = map.unproject([w, h]).toArray(),\n      cLL = map.unproject([0, h]).toArray();\n\n    return bboxPolygon([cLL, cUR].flat() as GeoJSON.BBox);\n  })();\n\n  const vertices: any[] = [];\n\n  // Keeps vertices for drwing guides\n  const addVerticesTovertices = (\n    coordinates: any,\n    isCurrentFeature = false\n  ) => {\n    if (!Array.isArray(coordinates)) throw Error(\"Your array is not an array\");\n\n    if (Array.isArray(coordinates[0])) {\n      // coordinates is an array of arrays, we must go deeper\n      coordinates.forEach((coord) => {\n        addVerticesTovertices(coord);\n      });\n    } else {\n      // If not an array of arrays, only consider arrays with two items\n      if (coordinates.length === 2) {\n        addPointTovertices(map, vertices, coordinates as any, isCurrentFeature);\n      }\n    }\n  };\n\n  features.forEach((feature) => {\n    // For currentfeature\n    if (feature.id === currentFeature.id) {\n      if (\n        currentFeature.type === geojsonTypes.POLYGON &&\n        !(\n          feature.geometry.type === \"GeometryCollection\" ||\n          feature.geometry.type === \"Point\"\n        )\n      ) {\n        // For the current polygon, the last two points are the mouse position and back home\n        // so we chop those off (else we get vertices showing where the user clicked, even\n        // if they were just panning the map)\n        addVerticesTovertices(\n          feature.geometry.coordinates[0].slice(0, -2),\n          true\n        );\n      }\n      return;\n    }\n\n    // If this is re-running because a user is moving the map, the features might include\n    // vertices or the last leg of a polygon\n    if (\n      feature.id === IDS.HORIZONTAL_GUIDE ||\n      feature.id === IDS.VERTICAL_GUIDE\n    )\n      return;\n\n    if (\n      !(\n        feature.geometry.type === \"GeometryCollection\" ||\n        feature.geometry.type === \"Point\"\n      )\n    ) {\n      addVerticesTovertices(feature.geometry.coordinates);\n    }\n\n    // If feature is currently on viewport add to snap list\n    if (!booleanDisjoint(bboxAsPolygon, feature)) {\n      snapList.push(feature);\n    }\n  });\n\n  return [snapList, vertices];\n};\n\nconst getNearbyvertices = (vertices: any, coords: any) => {\n  const verticals: any[] = [];\n  const horizontals: any[] = [];\n\n  vertices.forEach((vertex: any) => {\n    verticals.push(vertex[0]);\n    horizontals.push(vertex[1]);\n  });\n\n  const nearbyVerticalGuide = verticals.find(\n    (px) => Math.abs(px - coords.lng) < 0.009\n  );\n\n  const nearbyHorizontalGuide = horizontals.find(\n    (py) => Math.abs(py - coords.lat) < 0.009\n  );\n\n  return {\n    verticalPx: nearbyVerticalGuide,\n    horizontalPx: nearbyHorizontalGuide,\n  };\n};\n\nconst calcLayerDistances = (lngLat: any, layer: any) => {\n  // the point P which we want to snap (probpably the marker that is dragged)\n  const P = [lngLat.lng, lngLat.lat];\n\n  // is this a marker?\n  const isMarker = layer.geometry.type === \"Point\";\n  // is it a polygon?\n  const isPolygon = layer.geometry.type === \"Polygon\";\n  // is it a multiPolygon?\n  const isMultiPolygon = layer.geometry.type === \"MultiPolygon\";\n  // is it a multiPoint?\n  const isMultiPoint = layer.geometry.type === \"MultiPoint\";\n\n  let lines = undefined;\n\n  // the coords of the layer\n  const latlngs = getCoords(layer);\n\n  if (isMarker) {\n    const [lng, lat] = latlngs;\n    // return the info for the marker, no more calculations needed\n    return {\n      latlng: { lng, lat },\n      distance: distance(latlngs, P),\n    };\n  }\n\n  if (isMultiPoint) {\n    const np = nearestPointInPointSet(\n      P,\n      featureCollection(latlngs.map((x) => turfPoint(x)))\n    );\n    const c = np.geometry.coordinates;\n    return {\n      latlng: { lng: c[0], lat: c[1] },\n      distance: np.properties.distanceToPoint,\n    };\n  }\n\n  if (isPolygon || isMultiPolygon) {\n    lines = polygonToLine(layer);\n  } else {\n    lines = layer;\n  }\n\n  let nearestPoint;\n  if (isPolygon) {\n    let lineStrings;\n    if (lines.geometry.type === \"LineString\") {\n      lineStrings = [turfLineString(lines.geometry.coordinates)];\n    } else {\n      lineStrings = lines.geometry.coordinates.map((coords: any) =>\n        turfLineString(coords)\n      );\n    }\n\n    const closestFeature = getFeatureWithNearestPoint(lineStrings, P);\n    lines = closestFeature.feature;\n    nearestPoint = closestFeature.point;\n  } else if (isMultiPolygon) {\n    const lineStrings = lines.features\n      .map((feat: any) => {\n        if (feat.geometry.type === \"LineString\") {\n          return [feat.geometry.coordinates];\n        } else {\n          return feat.geometry.coordinates;\n        }\n      })\n      .flatMap((coords: any) => coords)\n      .map((coords: any) => turfLineString(coords));\n\n    const closestFeature = getFeatureWithNearestPoint(lineStrings, P);\n    lines = closestFeature.feature;\n    nearestPoint = closestFeature.point;\n  } else {\n    nearestPoint = nearestPointOnLine(lines, P);\n  }\n\n  const [lng, lat] = nearestPoint.geometry.coordinates;\n\n  let segmentIndex = nearestPoint.properties.index;\n  if (segmentIndex + 1 === lines.geometry.coordinates.length) segmentIndex--;\n\n  return {\n    latlng: { lng, lat },\n    segment: lines.geometry.coordinates.slice(segmentIndex, segmentIndex + 2),\n    distance: nearestPoint.properties.dist,\n    isMarker,\n  };\n};\n\nfunction getFeatureWithNearestPoint(lineStrings: any, P: any) {\n  const nearestPointsOfEachFeature = lineStrings.map((feat: any) => ({\n    feature: feat,\n    point: nearestPointOnLine(feat, P),\n  }));\n\n  nearestPointsOfEachFeature.sort(\n    (a: any, b: any) => a.point.properties.dist - b.point.properties.dist\n  );\n\n  return {\n    feature: nearestPointsOfEachFeature[0].feature,\n    point: nearestPointsOfEachFeature[0].point,\n  };\n}\n\nconst calcClosestLayer = (lngLat: any, layers: any) => {\n  let closestLayer: any = {};\n\n  // loop through the layers\n  layers.forEach((layer: any, index: any) => {\n    // find the closest latlng, segment and the distance of this layer to the dragged marker latlng\n    const results = calcLayerDistances(lngLat, layer);\n\n    // save the info if it doesn't exist or if the distance is smaller than the previous one\n    if (\n      closestLayer.distance === undefined ||\n      results.distance < closestLayer.distance\n    ) {\n      closestLayer = results;\n      closestLayer.layer = layer;\n    }\n  });\n\n  // return the closest layer and it's data\n  // if there is no closest layer, return undefined\n  return closestLayer;\n};\n\n// minimal distance before marker snaps (in pixels)\nconst metersPerPixel = function (latitude: any, zoomLevel: any) {\n  const earthCircumference = 40075017;\n  const latitudeRadians = latitude * (Math.PI / 180);\n  return (\n    (earthCircumference * Math.cos(latitudeRadians)) /\n    Math.pow(2, zoomLevel + 8)\n  );\n};\n\n// we got the point we want to snap to (C), but we need to check if a coord of the polygon\nfunction snapToLineOrPolygon(\n  closestLayer: any,\n  snapOptions: any,\n  snapVertexPriorityDistance: any\n) {\n  // A and B are the points of the closest segment to P (the marker position we want to snap)\n  const A = closestLayer.segment[0];\n  const B = closestLayer.segment[1];\n\n  // C is the point we would snap to on the segment.\n  // The closest point on the closest segment of the closest polygon to P. That's right.\n  const C = [closestLayer.latlng.lng, closestLayer.latlng.lat];\n\n  // distances from A to C and B to C to check which one is closer to C\n  const distanceAC = distance(A, C);\n  const distanceBC = distance(B, C);\n\n  // closest latlng of A and B to C\n  let closestVertexLatLng = distanceAC < distanceBC ? A : B;\n\n  // distance between closestVertexLatLng and C\n  let shortestDistance = distanceAC < distanceBC ? distanceAC : distanceBC;\n\n  // snap to middle (M) of segment if option is enabled\n  if (snapOptions && snapOptions.snapToMidPoints) {\n    const M = midpoint(A, B).geometry.coordinates;\n    const distanceMC = distance(M, C);\n\n    if (distanceMC < distanceAC && distanceMC < distanceBC) {\n      // M is the nearest vertex\n      closestVertexLatLng = M;\n      shortestDistance = distanceMC;\n    }\n  }\n\n  // the distance that needs to be undercut to trigger priority\n  const priorityDistance = snapVertexPriorityDistance;\n\n  // the latlng we ultemately want to snap to\n  let snapLatlng;\n\n  // if C is closer to the closestVertexLatLng (A, B or M) than the snapDistance,\n  // the closestVertexLatLng has priority over C as the snapping point.\n  if (shortestDistance < priorityDistance) {\n    snapLatlng = closestVertexLatLng;\n  } else {\n    snapLatlng = C;\n  }\n\n  // return the copy of snapping point\n  const [lng, lat] = snapLatlng;\n  return { lng, lat };\n}\n\nfunction snapToPoint(closestLayer: any) {\n  return closestLayer.latlng;\n}\n\nconst checkPrioritiySnapping = (\n  closestLayer: any,\n  snapOptions: any,\n  snapVertexPriorityDistance = 1.25\n) => {\n  let snappingToPoint = !Array.isArray(closestLayer.segment);\n  if (snappingToPoint) {\n    return snapToPoint(closestLayer);\n  } else {\n    return snapToLineOrPolygon(\n      closestLayer,\n      snapOptions,\n      snapVertexPriorityDistance\n    );\n  }\n};\n\n/**\n * Returns snap points if there are any, otherwise the original lng/lat of the event\n * Also, defines if vertices should show on the state object\n *\n * Mutates the state object\n *\n * @param state\n * @param e\n * @returns {{lng: number, lat: number}}\n */\nexport const snap = (state: any, e: any) => {\n  let lng = e.lngLat.lng;\n  let lat = e.lngLat.lat;\n\n  // Holding alt bypasses all snapping\n  if (e.originalEvent.altKey) {\n    state.showVerticalSnapLine = false;\n    state.showHorizontalSnapLine = false;\n\n    return { lng, lat };\n  }\n\n  if (state.snapList.length <= 0) {\n    return { lng, lat };\n  }\n\n  // snapping is on\n  let closestLayer, minDistance, snapLatLng;\n  if (state.options.snap) {\n    closestLayer = calcClosestLayer({ lng, lat }, state.snapList);\n\n    // if no layers found. Can happen when circle is the only visible layer on the map and the hidden snapping-border circle layer is also on the map\n    if (Object.keys(closestLayer).length === 0) {\n      return false;\n    }\n\n    const isMarker = closestLayer.isMarker;\n    const snapVertexPriorityDistance = state.options.snapOptions\n      ? state.options.snapOptions.snapVertexPriorityDistance\n      : undefined;\n\n    if (!isMarker) {\n      snapLatLng = checkPrioritiySnapping(\n        closestLayer,\n        state.options.snapOptions,\n        snapVertexPriorityDistance\n      );\n      // snapLatLng = closestLayer.latlng;\n    } else {\n      snapLatLng = closestLayer.latlng;\n    }\n\n    minDistance =\n      ((state.options.snapOptions && state.options.snapOptions.snapPx) || 15) *\n      metersPerPixel(snapLatLng.lat, state.map.getZoom());\n  }\n\n  let verticalPx, horizontalPx;\n  if (state.options.guides) {\n    const nearestGuidline = getNearbyvertices(state.vertices, e.lngLat);\n\n    verticalPx = nearestGuidline.verticalPx;\n    horizontalPx = nearestGuidline.horizontalPx;\n\n    if (verticalPx) {\n      // Draw a line from top to bottom\n\n      const lngLatTop = { lng: verticalPx, lat: e.lngLat.lat + 10 };\n      const lngLatBottom = { lng: verticalPx, lat: e.lngLat.lat - 10 };\n\n      state.verticalGuide.updateCoordinate(0, lngLatTop.lng, lngLatTop.lat);\n      state.verticalGuide.updateCoordinate(\n        1,\n        lngLatBottom.lng,\n        lngLatBottom.lat\n      );\n    }\n\n    if (horizontalPx) {\n      // Draw a line from left to right\n\n      const lngLatTop = { lng: e.lngLat.lng + 10, lat: horizontalPx };\n      const lngLatBottom = { lng: e.lngLat.lng - 10, lat: horizontalPx };\n\n      state.horizontalGuide.updateCoordinate(0, lngLatTop.lng, lngLatTop.lat);\n      state.horizontalGuide.updateCoordinate(\n        1,\n        lngLatBottom.lng,\n        lngLatBottom.lat\n      );\n    }\n\n    state.showVerticalSnapLine = !!verticalPx;\n    state.showHorizontalSnapLine = !!horizontalPx;\n  }\n\n  if (\n    minDistance &&\n    closestLayer &&\n    closestLayer.distance * 1000 < minDistance\n  ) {\n    return snapLatLng;\n  } else if (verticalPx || horizontalPx) {\n    if (verticalPx) {\n      lng = verticalPx;\n    }\n    if (horizontalPx) {\n      lat = horizontalPx;\n    }\n    return { lng, lat };\n  } else {\n    return { lng, lat };\n  }\n};\n\nexport const getGuideFeature = (id: any) => ({\n  id,\n  type: geojsonTypes.FEATURE,\n  properties: {\n    isSnapGuide: \"true\", // for styling\n  },\n  geometry: {\n    type: geojsonTypes.LINE_STRING,\n    coordinates: [],\n  },\n});\n\nexport const shouldHideGuide = (state: any, geojson: any) => {\n  if (\n    geojson.properties.id === IDS.VERTICAL_GUIDE &&\n    (!state.options.guides || !state.showVerticalSnapLine)\n  ) {\n    return true;\n  }\n\n  if (\n    geojson.properties.id === IDS.HORIZONTAL_GUIDE &&\n    (!state.options.guides || !state.showHorizontalSnapLine)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n","// index.ts\nimport { booleanDisjoint } from \"@turf/boolean-disjoint\";\nimport { flattenEach } from \"@turf/meta\";\nfunction booleanIntersects(feature1, feature2, options = {}) {\n  var _a;\n  const ignoreSelfIntersections = (_a = options.ignoreSelfIntersections) != null ? _a : false;\n  let bool = false;\n  flattenEach(feature1, (flatten1) => {\n    flattenEach(feature2, (flatten2) => {\n      if (bool === true) {\n        return true;\n      }\n      bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry, {\n        ignoreSelfIntersections\n      });\n    });\n  });\n  return bool;\n}\nvar turf_boolean_intersects_default = booleanIntersects;\nexport {\n  booleanIntersects,\n  turf_boolean_intersects_default as default\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null)\n    return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null)\n        continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\")\n              multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\")\n            multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\")\n              multiFeatureIndex++;\n            if (geomType === \"Polygon\")\n              geometryIndex++;\n          }\n          if (geomType === \"Polygon\")\n            multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false)\n          break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false)\n        break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else\n      previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry)\n      return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\")\n      return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson)\n    throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null)\n      return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options))\n    throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null)\n    return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0)\n        segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0)\n        geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options))\n    throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null)\n    return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0)\n        coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0)\n        geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport polygonClipping from \"polygon-clipping\";\nimport { polygon, multiPolygon } from \"@turf/helpers\";\nimport { geomEach } from \"@turf/meta\";\nfunction difference(features) {\n  const geoms = [];\n  geomEach(features, (geom) => {\n    geoms.push(geom.coordinates);\n  });\n  if (geoms.length < 2) {\n    throw new Error(\"Must have at least two features\");\n  }\n  const properties = features.features[0].properties || {};\n  const differenced = polygonClipping.difference(geoms[0], ...geoms.slice(1));\n  if (differenced.length === 0)\n    return null;\n  if (differenced.length === 1)\n    return polygon(differenced[0], properties);\n  return multiPolygon(differenced, properties);\n}\nvar turf_difference_default = difference;\nexport {\n  turf_difference_default as default,\n  difference\n};\n//# sourceMappingURL=index.js.map","import MapboxDraw, { DrawPolygon, lib } from \"@mapbox/mapbox-gl-draw\";\nconst { geojsonTypes, modes, cursors } = MapboxDraw.constants;\nconst { doubleClickZoom } = MapboxDraw.lib;\nconst DrawPolygonMode = MapboxDraw.modes.draw_polygon;\n\nimport {\n  addPointTovertices,\n  createSnapList,\n  getGuideFeature,\n  IDS,\n  shouldHideGuide,\n  snap,\n} from \"../utils\";\nimport booleanIntersects from \"@turf/boolean-intersects\";\nimport { difference } from \"@turf/difference\";\nimport { featureCollection, point } from \"@turf/helpers\";\nimport { Map } from \"mapbox-gl\";\n\nconst SnapPolygonMode = { ...DrawPolygonMode };\n\ntype State = {\n  map: Map;\n  polygon: DrawPolygon;\n  currentVertexPosition: number;\n  vertices: any;\n  snapList: any;\n  selectedFeatures: any;\n  verticalGuide: any;\n  horizontalGuide: any;\n  ghostPoint: GeoJSON.Feature<GeoJSON.Point>;\n  snappedLng: number;\n  snappedLat: number;\n  options: MapboxDraw.MapboxDrawOptions;\n  moveendCallback?: () => void;\n  optionsChangedCallBAck?: (options: any) => void;\n};\n\nSnapPolygonMode.onSetup = function (options) {\n  const polygon = this.newFeature({\n    type: geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: geojsonTypes.POLYGON,\n      coordinates: [[]],\n    },\n  }) as DrawPolygon;\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(polygon);\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const selectedFeatures = this.getSelected();\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n\n  const [snapList, vertices] = createSnapList(\n    this.map,\n    (this as any)._ctx.api,\n    polygon,\n    (this as any)._ctx.options.snapOptions.sources\n  );\n\n  const state: State = {\n    map: this.map,\n    polygon,\n    currentVertexPosition: 0,\n    vertices,\n    snapList,\n    selectedFeatures,\n    verticalGuide,\n    horizontalGuide,\n    snappedLat: 0,\n    snappedLng: 0,\n    ghostPoint: point([0, 0], { meta: \"feature\", active: \"true\" }),\n    /// Adding default options\n    options: (options = Object.assign((this as any)._ctx.options, {\n      overlap: true,\n    })),\n  };\n\n  const moveendCallback = () => {\n    const [snapList, vertices] = createSnapList(\n      this.map,\n      (this as any)._ctx.api,\n      polygon,\n      state.options.snapOptions.sources\n    );\n    state.vertices = vertices;\n    state.snapList = snapList;\n  };\n  // for removing listener later on close\n  state[\"moveendCallback\"] = moveendCallback;\n\n  const optionsChangedCallBAck = (options: any) => {\n    state.options = options;\n  };\n\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n\n  this.map.on(\"moveend\", moveendCallback);\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapPolygonMode.onClick = function (state: State, e) {\n  // We save some processing by rounding on click, not mousemove\n  const lng = state.snappedLng;\n  const lat = state.snappedLat;\n\n  // End the drawing if this click is on the previous position\n  if (state.currentVertexPosition > 0) {\n    this.updateUIClasses({ mouse: cursors.POINTER });\n\n    if (lib.CommonSelectors.isVertex(e)) {\n      return this.changeMode(modes.SIMPLE_SELECT, {\n        featureIds: [state.polygon.id],\n      });\n    }\n  }\n\n  addPointTovertices(state.map, state.vertices, { lng, lat });\n\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, lng, lat);\n\n  state.currentVertexPosition++;\n\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, lng, lat);\n};\n\nSnapPolygonMode.onMouseMove = function (state: State, e) {\n  const { lng, lat } = snap(state, e);\n  state.snappedLng = lng;\n  state.snappedLat = lat;\n\n  state.ghostPoint.geometry.coordinates = [lng, lat];\n\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, lng, lat);\n\n  if (lib.CommonSelectors.isVertex(e)) {\n    this.updateUIClasses({ mouse: cursors.POINTER });\n  } else {\n    this.updateUIClasses({ mouse: cursors.ADD });\n  }\n};\n\n// This is 'extending' DrawPolygon.toDisplayFeatures\nSnapPolygonMode.toDisplayFeatures = function (state: State, geojson, display) {\n  if (shouldHideGuide(state, geojson)) return;\n\n  display(state.ghostPoint);\n  // This relies on the the state of SnapPolygonMode being similar to DrawPolygon\n  (DrawPolygonMode as any).toDisplayFeatures(state, geojson, display);\n};\n\n// This is 'extending' DrawPolygon.onStop\nSnapPolygonMode.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  this.map.off(\"moveend\", state.moveendCallback);\n  this.map.off(\"draw.snap.options_changed\", state.optionsChangedCallBAck);\n\n  var userPolygon = state.polygon;\n  if (state.options.overlap) {\n    (DrawPolygonMode as any).onStop.call(this, state);\n    return;\n  }\n  // if overlap is false, mutate polygon so it doesnt overlap with existing ones\n  // get all editable features to check for intersections\n  var features = (this as any)._ctx.store.getAll();\n\n  try {\n    var edited = userPolygon;\n    features.forEach(function (feature: any) {\n      if (userPolygon.id === feature.id) return false;\n      if (!booleanIntersects(feature, edited)) return;\n      edited = difference(featureCollection([edited, feature]));\n    });\n    state.polygon.coordinates =\n      edited.coordinates || edited.geometry.coordinates;\n  } catch (err) {\n    // cancel this polygon if a difference cannot be calculated\n    (DrawPolygonMode as any).onStop.call(this, state);\n    this.deleteFeature(state.polygon.id, { silent: true });\n    return;\n  }\n\n  // monkeypatch so DrawPolygon.onStop doesn't error\n  var rc = state.polygon.removeCoordinate;\n  state.polygon.removeCoordinate = () => {};\n  // This relies on the the state of SnapPolygonMode being similar to DrawPolygon\n  (DrawPolygonMode as any).onStop.call(this, state);\n  state.polygon.removeCoordinate = rc.bind(state.polygon);\n};\n\nexport default SnapPolygonMode;\n","import MapboxDraw from \"@mapbox/mapbox-gl-draw\";\nimport { createSnapList, getGuideFeature, IDS, snap } from \"../utils\";\nconst { doubleClickZoom } = MapboxDraw.lib;\nconst DirectSelect = MapboxDraw.modes.direct_select;\nconst Constants = MapboxDraw.constants;\n\ninterface DirectSelectMode extends MapboxDraw.DrawCustomMode {\n  pathsToCoordinates: (featureId: string, paths: any) => any;\n  dragVertex: (state: any, e: any, delta: any) => void;\n}\n\nconst SnapDirectSelect = { ...(DirectSelect as DirectSelectMode) };\n\nSnapDirectSelect.onSetup = function (opts) {\n  const featureId = opts.featureId;\n  const feature = this.getFeature(featureId);\n\n  if (!feature) {\n    throw new Error(\"You must provide a featureId to enter direct_select mode\");\n  }\n\n  if (feature.type === Constants.geojsonTypes.POINT) {\n    throw new TypeError(\"direct_select mode doesn't handle point features\");\n  }\n\n  const [snapList, vertices] = createSnapList(\n    this.map,\n    (this as any)._ctx.api,\n    feature,\n    (this as any)._ctx.options.snapOptions.sources\n  );\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const state = {\n    map: this.map,\n    featureId,\n    feature,\n    dragMoveLocation: opts.startPos || null,\n    dragMoving: false,\n    canDragMove: false,\n    selectedCoordPaths: opts.coordPath ? [opts.coordPath] : [],\n    vertices,\n    snapList,\n    verticalGuide,\n    horizontalGuide,\n    options: {},\n    optionsChangedCallBAck: (options: any) => {},\n  };\n\n  state.options = (this as any)._ctx.options;\n\n  this.setSelectedCoordinates(\n    this.pathsToCoordinates(featureId, state.selectedCoordPaths)\n  );\n  this.setSelected(featureId);\n  doubleClickZoom.disable(this);\n\n  this.setActionableState({\n    trash: true,\n    combineFeatures: false,\n    uncombineFeatures: false,\n  });\n\n  const optionsChangedCallBAck = (options: any) => {\n    state.options = options;\n  };\n\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapDirectSelect.dragVertex = function (state, e, delta) {\n  const { lng, lat } = snap(state, e);\n\n  state.feature.updateCoordinate(state.selectedCoordPaths[0], lng, lat);\n};\n\nSnapDirectSelect.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  //   this.map.off(\"moveend\", state.moveendCallback);\n  this.map.off(\"draw.snap.options_changed\", state.optionsChangedCallBAck);\n\n  // This relies on the the state of SnapPolygonMode being similar to DrawPolygon\n  DirectSelect.onStop?.call(this, state);\n};\n\nexport default SnapDirectSelect;\n","import { lib } from \"@mapbox/mapbox-gl-draw\";\n\nconst modifiedDefaultStyles = lib.theme.map((defaultStyle) => {\n  if (defaultStyle.id === \"gl-draw-line-inactive\") {\n    return {\n      ...defaultStyle,\n      filter: [\n        ...(defaultStyle?.filter || []),\n        [\"!=\", \"user_isSnapGuide\", \"true\"],\n      ],\n    };\n  }\n\n  return defaultStyle;\n});\n\nconst customDrawStyles = [\n  ...modifiedDefaultStyles,\n  {\n    id: \"guide\",\n    type: \"line\",\n    filter: [\n      \"all\",\n      [\"==\", \"$type\", \"LineString\"],\n      [\"==\", \"user_isSnapGuide\", \"true\"],\n    ],\n    layout: {\n      \"line-cap\": \"round\",\n      \"line-join\": \"round\",\n    },\n    paint: {\n      \"line-color\": \"#c00c00\",\n      \"line-width\": 1,\n      \"line-dasharray\": [5, 5],\n    },\n  },\n];\n\nexport default customDrawStyles;\n"],"names":["module","exports","__generator","thisArg","body","f","y","t","g","_","label","sent","trys","ops","next","verb","Symbol","iterator","this","n","v","step","op","TypeError","call","done","value","pop","length","push","e","Node","key","data","left","right","DEFAULT_COMPARE","a","b","splay","i","comparator","N","l","r","cmp","insert","node","split","merge","printRow","root","prefix","isTail","out","printNode","indent","Tree","_root","_size","_comparator","prototype","add","remove","_remove","x","findStatic","current","compare","find","contains","forEach","visitor","ctx","Q","range","low","high","fn","keys","_a","values","min","minNode","max","maxNode","at","index","d","successor","prev","predecessor","clear","toList","load","presort","size","sort","loadRecursive","mergedList","mergeLists","createList","sortedListToBST","head","isEmpty","Object","defineProperty","get","enumerable","configurable","toString","String","join","update","newKey","newData","start","end","middle","Math","floor","p","list","l1","l2","p1","p2","pivot","j","tmp","isInBbox","bbox","point","ll","ur","getBboxOverlap","b1","b2","lowerX","upperX","epsilon$1","Number","EPSILON","undefined","pow","EPSILON_SQ","ab","PtRounder","constructor","reset","xRounder","CoordRounder","yRounder","round","tree","coord","prevNode","nextNode","rounder","epsilon","splitter","resulterrbound","sum","elen","flen","h","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","estimate","vec","Float64Array","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","orient2dadapt","ax","ay","bx","by","cx","cy","detsum","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","det","errbound","abs","C1len","C2len","Dlen","orient2d","detleft","detright","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","res","sqrt","sineOfAngle","pShared","pBase","pAngle","vBase","vAngle","cosineOfAngle","horizontalIntersection","pt","verticalIntersection","intersection$1","pt1","v1","pt2","v2","kross","ve","d1","d2","SweepEvent","ptCmp","comparePoints","link","isLeft","Segment","segment","aPt","bPt","events","other","Error","otherEvents","iMax","evt","checkForConsuming","numEvents","evt1","consumedBy","evt2","otherSE","consume","getAvailableLinkedEvents","ringOut","isInResult","getLeftmostComparator","baseEvent","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","cosine","has","asine","acosine","bsine","bcosine","segmentId","alx","leftSE","blx","arx","rightSE","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","id","rings","windings","fromRing","ring","leftPt","rightPt","winding","cmpPts","replaceRightSE","newRightSE","y1","y2","vector","isAnEndpoint","lPt","rPt","yDist","xFromYDist","xDist","yFromXDist","getIntersection","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","newEvents","alreadyLinked","newLeftSE","oldRightSE","newSeg","slice","swapEvents","tmpEvt","consumer","consumee","indexOf","prevInResult","_prevInResult","beforeState","_beforeState","seg","afterState","multiPolys","_afterState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","poly","isExterior","splice","mp","multiPoly","_isInResult","mpsBefore","operation","type","noBefores","noAfters","least","most","numMultiPolys","diff","isJustSubject","mps","isSubject","RingIn","geomRing","Array","isArray","segments","firstPoint","prevPoint","getSweepEvents","sweepEvents","PolyIn","geomPoly","exteriorRing","interiorRings","ringSweepEvents","jMax","MultiPolyIn","geom","ex","polys","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","RingOut","factory","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","firstPt","lastPt","indexLE","intersectionLE","ringEvents","unshift","reverse","getGeom","prevPt","points","nextPt","shift","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","addInterior","ringGeom","MultiPolyOut","_composePolys","polyGeom","SweepLine","queue","arguments","process","nextSeg","prevMySplitter","prevInter","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","mySplitter","inter","POLYGON_CLIPPING_MAX_QUEUE_SIZE","env","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","Operation","run","moreGeoms","multipolys","subject","mpA","sweepLine","prevQueueSize","union","_len","_key","intersection","_len2","_key2","xor","_len3","_key3","difference","subjectGeom","_len4","clippingGeoms","_key4","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","definition","o","obj","prop","hasOwnProperty","toStringTag","earthRadius","factors","centimeters","centimetres","degrees","PI","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","properties","options","feat","geometry","coordinates","polygon","featureCollection","features","fc","multiLineString","multiPolygon","radiansToLength","units","factor","lengthToRadians","distance","radiansToDegrees","degreesToRadians","num","isNaN","turf_bbox_polygon_default","west","south","east","north","lowLeft","ii","k","u1","u2","currentP","nextP","numContours","contourLen","contour","getCoord","getCoords","coords","geojson","booleanPointInPolygon","inBBox","result","polyResult","ignoreBoundary","TinyQueue","defaultCompare","_down","item","_up","top","bottom","peek","pos","parent","halfLength","best","checkWhichEventIsLeft","e1","e2","checkWhichSegmentHasRightEndpointFirst","seg1","seg2","rightSweepEvent","Event","featureId","ringId","eventId","otherEvent","isLeftEndpoint","isSamePoint","eventToCheck","processFeature","featureOrGeometry","eventQueue","iii","leftSweepEvent","testSegmentIntersect","x1","x2","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","ignoreSelfIntersections","fillEventQueue","intersectionPoints","outQueue","otherSeg","runCheck","lineIntersect","line1","line2","removeDuplicates","concat","intersections","results","unique","map","featureEach","callback","geomEach","stopG","geometryMaybeCollection","isGeometryCollection","featureProperties","featureBBox","featureIndex","isFeatureCollection","isFeature","stop","geometries","flattenEach","geomType","multiFeatureIndex","coordinate","polygonToLine","coordsToLine","singlePolygonToLine","lines","multiPolygonToLine","turf_polygon_to_line_default","booleanDisjoint","feature1","feature2","bool","flatten1","flatten2","geom1","geom2","pair1","pair2","isPointOnLine","lineString1","lineString2","doLinesIntersect","isLineOnLine","isLineInPoly","coord1","coord2","isPolyInPoly","disjoint","lineString","isPointOnLineSegment","lineSegmentStart","lineSegmentEnd","dxc","dyc","dxl","dyl","turf_boolean_disjoint_default","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","sin","cos","atan2","turf_distance_default","bearing","final","bear","calculateFinalBearing","lon1","lon2","destination","origin","longitude1","latitude1","bearingRad","latitude2","asin","__defProp","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","__propIsEnum","propertyIsEnumerable","__defNormalProp","writable","__spreadValues","__spreadProps","turf_nearest_point_on_line_default","closestPt","Infinity","dist","location","line","_featureIndex","sectionLength","heightDistance","direction","perpendicularPt1","perpendicularPt2","intersect","intersectPt","clone","cloneFeature","cloned","feature","cloneFeatureCollection","cloneGeometry","cloneProperties","deepSlice","turf_nearest_point_default","targetPoint","minDist","bestFeatureIndex","distanceToPoint","nearestPoint2","turf_midpoint_default","point1","point2","geojsonTypes","IDS","VERTICAL_GUIDE","HORIZONTAL_GUIDE","addPointTovertices","vertices","forceInclusion","width","w","height","getCanvas","project","createSnapList","draw","currentFeature","sourcesIds","sourcesFeatures","source","getSource","sourceData","_data","flat","getAll","snapList","bboxAsPolygon","canvas","cUR","unproject","toArray","cLL","addVerticesTovertices","isCurrentFeature","POLYGON","getFeatureWithNearestPoint","lineStrings","P","nearestPointsOfEachFeature","calcClosestLayer","lngLat","layers","closestLayer","layer","lng","lat","isMarker","isPolygon","isMultiPolygon","isMultiPoint","latlngs","latlng","np","nearestPoint","closestFeature","flatMap","segmentIndex","calcLayerDistances","checkPrioritiySnapping","snapOptions","snapVertexPriorityDistance","snapToPoint","A","C","distanceAC","distanceBC","snapLatlng","closestVertexLatLng","shortestDistance","snapToMidPoints","M","distanceMC","snapToLineOrPolygon","snap","state","minDistance","snapLatLng","verticalPx","horizontalPx","originalEvent","altKey","showVerticalSnapLine","showHorizontalSnapLine","snapPx","latitude","zoomLevel","latitudeRadians","metersPerPixel","getZoom","guides","nearestGuidline","verticals","horizontals","vertex","px","py","getNearbyvertices","lngLatTop","lngLatBottom","verticalGuide","updateCoordinate","horizontalGuide","getGuideFeature","FEATURE","isSnapGuide","LINE_STRING","shouldHideGuide","turf_boolean_intersects_default","geoms","differenced","modes","cursors","doubleClickZoom","DrawPolygonMode","draw_polygon","SnapPolygonMode","onSetup","newFeature","addFeature","selectedFeatures","getSelected","clearSelectedFeatures","disable","_ctx","api","sources","currentVertexPosition","snappedLat","snappedLng","ghostPoint","meta","active","assign","overlap","moveendCallback","optionsChangedCallBAck","on","onClick","updateUIClasses","mouse","POINTER","lib","CommonSelectors","isVertex","changeMode","SIMPLE_SELECT","featureIds","onMouseMove","ADD","toDisplayFeatures","display","onStop","deleteFeature","silent","off","userPolygon","store","edited","err","rc","removeCoordinate","bind","DirectSelect","direct_select","Constants","SnapDirectSelect","opts","getFeature","POINT","dragMoveLocation","startPos","dragMoving","canDragMove","selectedCoordPaths","coordPath","setSelectedCoordinates","pathsToCoordinates","setSelected","setActionableState","trash","combineFeatures","uncombineFeatures","dragVertex","delta","theme","defaultStyle","filter","layout","paint"],"sourceRoot":""}